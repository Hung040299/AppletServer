/* tslint:disable */

/**
 * River_Applet_Server
 * Appletサーバ。
 *
 * OpenAPI spec version: 0.0.8
 *
 *
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git
 * Do not edit the class manually.
 */

import localVarRequest = require("request");
import http = require("http");
import {
  DodaiResponseType
} from "../../api/type/type";
import * as riiiverdb from "user-session/riiiverdb";
const config = require("../api/controllers/config");
let defaultBasePath = config.server + "/api";

// ===============================================
// This file is autogenerated - Please do not edit
// ===============================================

/* tslint:disable:no-unused-variable */
let primitives = [
  "string",
  "boolean",
  "double",
  "integer",
  "long",
  "float",
  "number",
  "any"
];

class ObjectSerializer {
  public static findCorrectType(data: any, expectedType: string) {
    if (data == undefined) {
      return expectedType;
    } else if (primitives.indexOf(expectedType.toLowerCase()) !== -1) {
      return expectedType;
    } else if (expectedType === "Date") {
      return expectedType;
    } else {
      if (enumsMap[expectedType]) {
        return expectedType;
      }

      if (!typeMap[expectedType]) {
        return expectedType; // w/e we don't know the type
      }

      // Check the discriminator
      let discriminatorProperty = typeMap[expectedType].discriminator;
      if (discriminatorProperty == null) {
        return expectedType; // the type does not have a discriminator. use it.
      } else {
        if (data[discriminatorProperty]) {
          return data[discriminatorProperty]; // use the type given in the discriminator
        } else {
          return expectedType; // discriminator was not present (or an empty string)
        }
      }
    }
  }

  public static serialize(data: any, type: string) {
    if (data == undefined) {
      return data;
    } else if (primitives.indexOf(type.toLowerCase()) !== -1) {
      return data;
    } else if (type.lastIndexOf("Array<", 0) === 0) {
      // string.startsWith pre es6
      let subType: string = type.replace("Array<", ""); // Array<Type> => Type>
      subType = subType.substring(0, subType.length - 1); // Type> => Type
      let transformedData: any[] = [];
      for (let index in data) {
        let date = data[index];
        transformedData.push(ObjectSerializer.serialize(date, subType));
      }
      return transformedData;
    } else if (type === "Date") {
      return data.toString();
    } else {
      if (enumsMap[type]) {
        return data;
      }
      if (!typeMap[type]) {
        // in case we dont know the type
        return data;
      }

      // get the map for the correct type.
      let attributeTypes = typeMap[type].getAttributeTypeMap();
      let instance: { [index: string]: any } = {};
      for (let index in attributeTypes) {
        let attributeType = attributeTypes[index];
        instance[attributeType.baseName] = ObjectSerializer.serialize(
          data[attributeType.name],
          attributeType.type
        );
      }
      return instance;
    }
  }

  public static deserialize(data: any, type: string) {
    // polymorphism may change the actual type.
    type = ObjectSerializer.findCorrectType(data, type);
    if (data == undefined) {
      return data;
    } else if (primitives.indexOf(type.toLowerCase()) !== -1) {
      return data;
    } else if (type.lastIndexOf("Array<", 0) === 0) {
      // string.startsWith pre es6
      let subType: string = type.replace("Array<", ""); // Array<Type> => Type>
      subType = subType.substring(0, subType.length - 1); // Type> => Type
      let transformedData: any[] = [];
      for (let index in data) {
        let date = data[index];
        transformedData.push(ObjectSerializer.deserialize(date, subType));
      }
      return transformedData;
    } else if (type === "Date") {
      return new Date(data);
    } else {
      if (enumsMap[type]) {
        // is Enum
        return data;
      }

      if (!typeMap[type]) {
        // dont know the type
        return data;
      }
      let instance = new typeMap[type]();
      let attributeTypes = typeMap[type].getAttributeTypeMap();
      for (let index in attributeTypes) {
        let attributeType = attributeTypes[index];
        instance[attributeType.name] = ObjectSerializer.deserialize(
          data[attributeType.baseName],
          attributeType.type
        );
      }
      return instance;
    }
  }
}

/**
 * ActionProxyの情報。
 */
export class ActionProxyData {
  /**
   * Blockで使用するActionProxyCoreの名前。
   */
  "service"?: string;
  /**
   * BlockCoreがOSから取得するデータのパラメータリスト。
   */
  "parameters"?: Array<ActionProxyData.ParametersEnum>;
  "authType"?: AuthType;

  static discriminator = undefined;

  static attributeTypeMap: Array<{
    name: string;
    baseName: string;
    type: string;
  }> = [
    {
      name: "service",
      baseName: "service",
      type: "string"
    },
    {
      name: "parameters",
      baseName: "parameters",
      type: "Array<ActionProxyData.ParametersEnum>"
    },
    {
      name: "authType",
      baseName: "authType",
      type: "AuthType"
    }
  ];

  static getAttributeTypeMap() {
    return ActionProxyData.attributeTypeMap;
  }
}

export namespace ActionProxyData {
  export enum ParametersEnum {
    Location = <any>"location"
  }
}
/**
 * Appletテンプレート利用時の2つ目以降のAction Block IDの列 1つ目のTrigger Blockは\"action\"に指定されたものとし、2つ目以降をこの配列に格納 処理の優先順位がある場合、\"action\"に記載されたもの→配列に記載されたBlockの先頭から末尾の順となる
 */
export class Actions extends Array<string> {
  static discriminator = undefined;
}

/**
 * Appletオブジェクト。Blockの組み合わせを記述する。ユーザは自由にAppletを作成できる。 商用でどういうデータ構造になるかはまだ検討が必要だが、プロトタイプではtrigger/service/actionの3段階構成で、 それぞれBlockのIDを記述して組み合わせる。
 */
export class Applet {
  /**
   * Appletに固有のID。サーバが生成する。
   */
  "id": string;
  "title": I18nObject;
  "description"?: I18nObject;
  "toolIds": Array<ToolId>;
  "categoryIds": Array<CategoryId>;
  "vendorId": VendorId;
  "deviceId": DeviceTypeId;
  /**
   * アイコンのURL
   */
  "iconUrl": string;
  "version": AppletVersion;
  /**
   * Trigger BlockのID。
   */
  "trigger": string;
  /**
   * Service BlockのID。
   */
  "service": string;
  /**
   * Action BlockのID。
   */
  "action": string;
  "wirings"?: AppletWirings;
  "preferences"?: AppletPreferences;
  "permissionList"?: PermissionList;
  /**
   * 外部APIのoauth認証が必要な場合は入力。(ServiceBlockから持ってくる)
   */
  "oauthServiceType"?: Applet.OauthServiceTypeEnum;
  "serviceProxy"?: ServiceProxyData;
  "actionProxy"?: ActionProxyData;
  "proxies"?: Proxies;
  /**
   * 削除扱いにする場合、trueにする。
   */
  "isDeleted"?: boolean;
  "templateType"?: TemplateType;
  "triggers"?: Triggers;
  "services"?: Services;
  "actions"?: Actions;
  "osType": string;

  static discriminator = undefined;

  static attributeTypeMap: Array<{
    name: string;
    baseName: string;
    type: string;
  }> = [
    {
      name: "id",
      baseName: "id",
      type: "string"
    },
    {
      name: "title",
      baseName: "title",
      type: "I18nObject"
    },
    {
      name: "description",
      baseName: "description",
      type: "I18nObject"
    },
    {
      name: "toolIds",
      baseName: "toolIds",
      type: "Array<ToolId>"
    },
    {
      name: "categoryIds",
      baseName: "categoryIds",
      type: "Array<CategoryId>"
    },
    {
      name: "vendorId",
      baseName: "vendorId",
      type: "VendorId"
    },
    {
      name: "deviceId",
      baseName: "deviceId",
      type: "DeviceTypeId"
    },
    {
      name: "iconUrl",
      baseName: "iconUrl",
      type: "string"
    },
    {
      name: "version",
      baseName: "version",
      type: "AppletVersion"
    },
    {
      name: "trigger",
      baseName: "trigger",
      type: "string"
    },
    {
      name: "service",
      baseName: "service",
      type: "string"
    },
    {
      name: "action",
      baseName: "action",
      type: "string"
    },
    {
      name: "wirings",
      baseName: "wirings",
      type: "AppletWirings"
    },
    {
      name: "preferences",
      baseName: "preferences",
      type: "AppletPreferences"
    },
    {
      name: "permissionList",
      baseName: "permissionList",
      type: "PermissionList"
    },
    {
      name: "oauthServiceType",
      baseName: "oauthServiceType",
      type: "Applet.OauthServiceTypeEnum"
    },
    {
      name: "serviceProxy",
      baseName: "serviceProxy",
      type: "ServiceProxyData"
    },
    {
      name: "actionProxy",
      baseName: "actionProxy",
      type: "ActionProxyData"
    },
    {
      name: "proxies",
      baseName: "proxies",
      type: "Proxies"
    },
    {
      name: "isDeleted",
      baseName: "isDeleted",
      type: "boolean"
    },
    {
      name: "templateType",
      baseName: "templateType",
      type: "TemplateType"
    },
    {
      name: "triggers",
      baseName: "triggers",
      type: "Triggers"
    },
    {
      name: "services",
      baseName: "services",
      type: "Services"
    },
    {
      name: "actions",
      baseName: "actions",
      type: "Actions"
    },
    {
      name: "osType",
      baseName: "osType",
      type: "string"
    }
  ];

  static getAttributeTypeMap() {
    return Applet.attributeTypeMap;
  }
}

export namespace Applet {
  export enum OauthServiceTypeEnum {
    Oauth = <any>"oauth"
  }
}
/**
 * Appletのダウンロード数
 */
export class AppletDownloadNum {
  /**
   * Appletの固有のID。
   */
  "appletId"?: string;
  /**
   * idのAppletのダウンロード数
   */
  "num"?: number;

  static discriminator = undefined;

  static attributeTypeMap: Array<{
    name: string;
    baseName: string;
    type: string;
  }> = [
    {
      name: "appletId",
      baseName: "appletId",
      type: "string"
    },
    {
      name: "num",
      baseName: "num",
      type: "number"
    }
  ];

  static getAttributeTypeMap() {
    return AppletDownloadNum.attributeTypeMap;
  }
}

/**
 * Appletのイイネ！の総数
 */
export class AppletGoodNum {
  /**
   * idのAppletのイイネ！の総数
   */
  "num"?: number;

  static discriminator = undefined;

  static attributeTypeMap: Array<{
    name: string;
    baseName: string;
    type: string;
  }> = [
    {
      name: "num",
      baseName: "num",
      type: "number"
    }
  ];

  static getAttributeTypeMap() {
    return AppletGoodNum.attributeTypeMap;
  }
}

/**
 * Appletそのものとは別のAppletに関する情報
 */
export class AppletInfo {
  /**
   * Appletに固有のID。サーバが生成する。
   */
  "id": string;
  /**
   * オーナー
   */
  "ownerId": string;
  "likeNum": number;
  "downloadNum": number;
  "publicStatus": boolean;
  "storeStatus": AppletInfo.StoreStatusEnum;
  "release"?: string;
  "compatible"?: Array<AppletInfoCompatible>;

  static discriminator = undefined;

  static attributeTypeMap: Array<{
    name: string;
    baseName: string;
    type: string;
  }> = [
    {
      name: "id",
      baseName: "id",
      type: "string"
    },
    {
      name: "ownerId",
      baseName: "ownerId",
      type: "string"
    },
    {
      name: "likeNum",
      baseName: "likeNum",
      type: "number"
    },
    {
      name: "downloadNum",
      baseName: "downloadNum",
      type: "number"
    },
    {
      name: "publicStatus",
      baseName: "publicStatus",
      type: "boolean"
    },
    {
      name: "storeStatus",
      baseName: "storeStatus",
      type: "AppletInfo.StoreStatusEnum"
    },
    {
      name: "release",
      baseName: "release",
      type: "string"
    },
    {
      name: "compatible",
      baseName: "compatible",
      type: "Array<AppletInfoCompatible>"
    },
    {
      name: "submitDate",
      baseName: "submitDate",
      type: "Date"
    }
  ];

  static getAttributeTypeMap() {
    return AppletInfo.attributeTypeMap;
  }
}

export namespace AppletInfo {
  export enum StoreStatusEnum {
    Published = <any>"published",
    WaitingReview = <any>"waiting_review",
    Rejected = <any>"rejected",
    Deleted = <any>"deleted"
  }
}
export class AppletInfoCompatible {
  "vendor"?: string;
  "models"?: Array<string>;

  static discriminator = undefined;

  static attributeTypeMap: Array<{
    name: string;
    baseName: string;
    type: string;
  }> = [
    {
      name: "vendor",
      baseName: "vendor",
      type: "string"
    },
    {
      name: "models",
      baseName: "models",
      type: "Array<string>"
    }
  ];

  static getAttributeTypeMap() {
    return AppletInfoCompatible.attributeTypeMap;
  }
}

/**
 * 各Blockのpreferencesに具体的な値を設定した辞書オブジェクト。 keyはBlockのID、valueは`object`。Valueの`object`は、Blockの`preferences`に含まれる`properties`をkey、設定値をvalueとする。 ストアの存在とAppletの共有を前提とする環境下では、ここで定める値はApplet作成者の決めたデフォルト値という扱いで、 Applet使用者は一部または全部の値を自分でカスタマイズしても良い。 カスタマイズした場合、ユーザ個別のpreferencesは別リソースとなる見込みだが、プロトタイプではユーザ端末上のアプリ内のローカルな状態で構わない。
 */
export class AppletPreferences {
  static discriminator = undefined;

  static attributeTypeMap: Array<{
    name: string;
    baseName: string;
    type: string;
  }> = [];

  static getAttributeTypeMap() {
    return AppletPreferences.attributeTypeMap;
  }
}

/**
 * Appletの公開・非公開の設定(ディベロッパが決める)
 */
export class AppletPublicStatus {
  /**
   * idのAppletの公開・非公開
   */
  "status"?: boolean;

  static discriminator = undefined;

  static attributeTypeMap: Array<{
    name: string;
    baseName: string;
    type: string;
  }> = [
    {
      name: "status",
      baseName: "status",
      type: "boolean"
    }
  ];

  static getAttributeTypeMap() {
    return AppletPublicStatus.attributeTypeMap;
  }
}

/**
 * Appletの申請状態の管理
 */
export class AppletStoreStatus {
  /**
   * Aplletのステータス \"published\"->審査OK \"waiting_review\"->審査待ち \"rejected\"->審査NG \"deleted\"->削除済み
   */
  "status"?: AppletStoreStatus.StatusEnum;
  /**
   * 審査でリジェクトされた場合のメッセージ
   */
  "message"?: string;
  /**
   * データ生成時刻(UTC)
   */
  "release"?: string;

  static discriminator = undefined;

  static attributeTypeMap: Array<{
    name: string;
    baseName: string;
    type: string;
  }> = [
    {
      name: "status",
      baseName: "status",
      type: "AppletStoreStatus.StatusEnum"
    },
    {
      name: "message",
      baseName: "message",
      type: "string"
    },
    {
      name: "release",
      baseName: "release",
      type: "string"
    }
  ];

  static getAttributeTypeMap() {
    return AppletStoreStatus.attributeTypeMap;
  }
}

export namespace AppletStoreStatus {
  export enum StatusEnum {
    Published = <any>"published",
    WaitingReview = <any>"waiting_review",
    Rejected = <any>"rejected",
    Deleted = <any>"deleted"
  }
}
/**
 * Appletテンプレートを規定するオブジェクト
 */
export class AppletTemplate {
  /**
   * AppletテンプレートのID システム自動採番
   */
  "id"?: string;
  /**
   * Appletテンプレートの名称
   */
  "name": I18nObject;
  /**
   * Appletテンプレートの説明
   */
  "description"?: I18nObject;
  "templateType": TemplateType;
  /**
   * このAppletテンプレートに設定できるTrigger Blockの個数
   */
  "triggers": number;
  /**
   * このAppletテンプレートに設定できるService Blockの個数
   */
  "services": number;
  /**
   * このAppletテンプレートに設定できるAction Blockの個数
   */
  "actions": number;
  /**
   * このAppletテンプレートに設定できる各Blockのinput type定義
   */
  "input"?: TemplateInputRequired;
  /**
   * このAppletテンプレートに設定できる各Blockのoutput type定義
   */
  "output"?: TemplateOutputRequired;
  /**
   * このAppletテンプレートでのWiring定義 実際にAppletを作るときには、このWiring定義が優先される
   */
  "wirings"?: AppletWirings;
  /**
   * このAppletテンプレートでのPreference定義
   */
  "templatePreference"?: AppletPreferences;

  static discriminator = undefined;

  static attributeTypeMap: Array<{
    name: string;
    baseName: string;
    type: string;
  }> = [
    {
      name: "id",
      baseName: "id",
      type: "string"
    },
    {
      name: "name",
      baseName: "name",
      type: "I18nObject"
    },
    {
      name: "description",
      baseName: "description",
      type: "I18nObject"
    },
    {
      name: "templateType",
      baseName: "templateType",
      type: "TemplateType"
    },
    {
      name: "triggers",
      baseName: "triggers",
      type: "number"
    },
    {
      name: "services",
      baseName: "services",
      type: "number"
    },
    {
      name: "actions",
      baseName: "actions",
      type: "number"
    },
    {
      name: "input",
      baseName: "input",
      type: "TemplateInputRequired"
    },
    {
      name: "output",
      baseName: "output",
      type: "TemplateOutputRequired"
    },
    {
      name: "wirings",
      baseName: "wirings",
      type: "AppletWirings"
    },
    {
      name: "templatePreference",
      baseName: "templatePreference",
      type: "AppletPreferences"
    }
  ];

  static getAttributeTypeMap() {
    return AppletTemplate.attributeTypeMap;
  }
}

/**
 * Appletのバージョン。 バージョンナンバーは X.Y.Z の形式で記述するものとする。 X、Y、Z は負でない整数値でなくてはならず、各数値の先頭に0を配置してはならない。
 */
export class AppletVersion {
  static discriminator = undefined;

  static attributeTypeMap: Array<{
    name: string;
    baseName: string;
    type: string;
  }> = [];

  static getAttributeTypeMap() {
    return AppletVersion.attributeTypeMap;
  }
}

/**
 * AppletとAppletInfoをまとめたもの。
 */
export class AppletWholeInfo {
  /**
   * Appletに固有のID。サーバが生成する。
   */
  "id": string;
  "applet": Applet;
  "appletInfo": AppletInfo;

  static discriminator = undefined;

  static attributeTypeMap: Array<{
    name: string;
    baseName: string;
    type: string;
  }> = [
    {
      name: "id",
      baseName: "id",
      type: "string"
    },
    {
      name: "applet",
      baseName: "applet",
      type: "Applet"
    },
    {
      name: "appletInfo",
      baseName: "appletInfo",
      type: "AppletInfo"
    }
  ];

  static getAttributeTypeMap() {
    return AppletWholeInfo.attributeTypeMap;
  }
}

/**
 * AppletWiringsオブジェクトのleafとなるオブジェクト。`input`に入力するための値を出力する元となる`output`を指定する。
 */
export class AppletWiringSource {
  /**
   * BlockのID。
   */
  "id": string;
  /**
   * 値の出力元となる、Blockの`output`に含まれるproperty名。 プロトタイプでは、入力対象である`input` propertyとは`type`が一致しなければならない。（暗黙の型変換などは規定しない）
   */
  "property": string;

  static discriminator = undefined;

  static attributeTypeMap: Array<{
    name: string;
    baseName: string;
    type: string;
  }> = [
    {
      name: "id",
      baseName: "id",
      type: "string"
    },
    {
      name: "property",
      baseName: "property",
      type: "string"
    }
  ];

  static getAttributeTypeMap() {
    return AppletWiringSource.attributeTypeMap;
  }
}

/**
 * Block間の`input`/`output`をどのように結びつけるか定めた辞書オブジェクト。結線規則。 keyは`input`を受け取る側のBlockのID、valueは`object`。Valueの`object`はBlockの`input`に含まれる`properties`をkey、 AppletWiringSourceオブジェクトをvalueとする。 あるBlockの`output`の一部または全部を不要な場合に読み捨てることはAppletの実行上問題を来さないが、 **`input`に不足がある場合はAppletの実行が不可能になる**ことから、`input`が全て充足していることがAppletの成立条件であり、従ってWiringでも`input`を起点として記述する。 省略される可能性もあることに注意する。例えば、`default`値をもっている`input` propertyに関する規則や、 `input`に有効なpropertyを持たないBlockに関する規則などは省略可能である。 このオブジェクトはApplet作成者がApplet作成アプリ上で編集した内容をJSONとして表現したものになる。 今後の検討課題として、値の暗黙的な変換規則の整備や、明示的な変換・編集などを記述できるようにするかどうか、 といった点が上がっている。が、プロトタイプの間は`type`の一致を検証する程度で、Blockの実装側で値の形式は既知として進める予定。
 */
export class AppletWirings {
  static discriminator = undefined;

  static attributeTypeMap: Array<{
    name: string;
    baseName: string;
    type: string;
  }> = [];

  static getAttributeTypeMap() {
    return AppletWirings.attributeTypeMap;
  }
}

/**
 * 認証タイプ。 認証なしの場合はこのパラメータはセットされない。
 */
export class AuthType extends Array<string> {
  static discriminator = undefined;
  static attributeTypeMap: Array<{
    name: string;
    baseName: string;
    type: string;
  }> = [];

  static getAttributeTypeMap() {
    return AuthType.attributeTypeMap;
  }
}

/**
 * 400 Bad Requestとともに返却されるエラーオブジェクト。 API仕様に定めたJSON schemaにマッチしなかった場合などにこのエラーとなる。 エラー内容は現状では正規化されてはいないが、正規化する場合はDodaiのエラーレスポンス形式に合わせる。
 */
export class BadRequest {
  static discriminator = undefined;

  static attributeTypeMap: Array<{
    name: string;
    baseName: string;
    type: string;
  }> = [];

  static getAttributeTypeMap() {
    return BadRequest.attributeTypeMap;
  }
}

export class Body {
  "appletId": string;
  "toolIds": Array<ToolId>;
  "categoryIds": Array<CategoryId>;
  "vendorId": VendorId;
  "deviceId": DeviceTypeId;
  "iconUrl": string;
  "title": I18nObject;
  "version": AppletVersion;
  "description"?: I18nObject;
  "compatible"?: Compatible;
  "trigger": string;
  "service": string;
  "action": string;
  "wirings"?: AppletWirings;
  "preferences"?: AppletPreferences;
  "permissionList"?: PermissionList;
  /**
   * 外部APIのoauth認証が必要な場合は入力。(ServiceBlockから持ってくる)
   */
  "oauthServiceType"?: Body.OauthServiceTypeEnum;
  "serviceProxy"?: ServiceProxyData;
  "actionProxy"?: ActionProxyData;
  "_public": boolean;
  "proxies"?: Proxies;
  "templateType"?: TemplateType;
  "triggers"?: Triggers;
  "services"?: Services;
  "actions"?: Actions;
  "osType": OsType;

  static discriminator = undefined;

  static attributeTypeMap: Array<{
    name: string;
    baseName: string;
    type: string;
  }> = [
    {
      name: "appletId",
      baseName: "appletId",
      type: "string"
    },
    {
      name: "toolIds",
      baseName: "toolIds",
      type: "Array<ToolId>"
    },
    {
      name: "categoryIds",
      baseName: "categoryIds",
      type: "Array<CategoryId>"
    },
    {
      name: "vendorId",
      baseName: "vendorId",
      type: "VendorId"
    },
    {
      name: "deviceId",
      baseName: "deviceId",
      type: "DeviceTypeId"
    },
    {
      name: "iconUrl",
      baseName: "iconUrl",
      type: "string"
    },
    {
      name: "title",
      baseName: "title",
      type: "I18nObject"
    },
    {
      name: "version",
      baseName: "version",
      type: "AppletVersion"
    },
    {
      name: "description",
      baseName: "description",
      type: "I18nObject"
    },
    {
      name: "compatible",
      baseName: "compatible",
      type: "Compatible"
    },
    {
      name: "trigger",
      baseName: "trigger",
      type: "string"
    },
    {
      name: "service",
      baseName: "service",
      type: "string"
    },
    {
      name: "action",
      baseName: "action",
      type: "string"
    },
    {
      name: "wirings",
      baseName: "wirings",
      type: "AppletWirings"
    },
    {
      name: "preferences",
      baseName: "preferences",
      type: "AppletPreferences"
    },
    {
      name: "permissionList",
      baseName: "permissionList",
      type: "PermissionList"
    },
    {
      name: "oauthServiceType",
      baseName: "oauthServiceType",
      type: "Body.OauthServiceTypeEnum"
    },
    {
      name: "serviceProxy",
      baseName: "serviceProxy",
      type: "ServiceProxyData"
    },
    {
      name: "actionProxy",
      baseName: "actionProxy",
      type: "ActionProxyData"
    },
    {
      name: "_public",
      baseName: "public",
      type: "boolean"
    },
    {
      name: "proxies",
      baseName: "proxies",
      type: "Proxies"
    },
    {
      name: "templateType",
      baseName: "templateType",
      type: "TemplateType"
    },
    {
      name: "triggers",
      baseName: "triggers",
      type: "Triggers"
    },
    {
      name: "services",
      baseName: "services",
      type: "Services"
    },
    {
      name: "actions",
      baseName: "actions",
      type: "Actions"
    },
    {
      name: "osType",
      baseName: "osType",
      type: "OsType"
    }
  ];

  static getAttributeTypeMap() {
    return Body.attributeTypeMap;
  }
}

export namespace Body {
  export enum OauthServiceTypeEnum {
    Oauth = <any>"oauth"
  }
}
export class Body1 {
  "toolIds": Array<ToolId>;
  "categoryIds": Array<CategoryId>;
  "vendorId": VendorId;
  "deviceId": DeviceTypeId;
  "iconUrl": string;
  "title": I18nObject;
  "version": AppletVersion;
  "description"?: I18nObject;
  "compatible"?: Compatible;
  "trigger": string;
  "service": string;
  "action": string;
  "wirings"?: AppletWirings;
  "preferences"?: AppletPreferences;
  "permissionList"?: PermissionList;
  /**
   * 外部APIのoauth認証が必要な場合は入力。(ServiceBlockから持ってくる)
   */
  "oauthServiceType"?: Body1.OauthServiceTypeEnum;
  "serviceProxy"?: ServiceProxyData;
  "actionProxy"?: ActionProxyData;
  "_public": boolean;
  "proxies"?: Proxies;
  "templateType"?: TemplateType;
  "triggers"?: Triggers;
  "services"?: Services;
  "actions"?: Actions;
  "osType": OsType;

  static discriminator = undefined;

  static attributeTypeMap: Array<{
    name: string;
    baseName: string;
    type: string;
  }> = [
    {
      name: "toolIds",
      baseName: "toolIds",
      type: "Array<ToolId>"
    },
    {
      name: "categoryIds",
      baseName: "categoryIds",
      type: "Array<CategoryId>"
    },
    {
      name: "vendorId",
      baseName: "vendorId",
      type: "VendorId"
    },
    {
      name: "deviceId",
      baseName: "deviceId",
      type: "DeviceTypeId"
    },
    {
      name: "iconUrl",
      baseName: "iconUrl",
      type: "string"
    },
    {
      name: "title",
      baseName: "title",
      type: "I18nObject"
    },
    {
      name: "version",
      baseName: "version",
      type: "AppletVersion"
    },
    {
      name: "description",
      baseName: "description",
      type: "I18nObject"
    },
    {
      name: "compatible",
      baseName: "compatible",
      type: "Compatible"
    },
    {
      name: "trigger",
      baseName: "trigger",
      type: "string"
    },
    {
      name: "service",
      baseName: "service",
      type: "string"
    },
    {
      name: "action",
      baseName: "action",
      type: "string"
    },
    {
      name: "wirings",
      baseName: "wirings",
      type: "AppletWirings"
    },
    {
      name: "preferences",
      baseName: "preferences",
      type: "AppletPreferences"
    },
    {
      name: "permissionList",
      baseName: "permissionList",
      type: "PermissionList"
    },
    {
      name: "oauthServiceType",
      baseName: "oauthServiceType",
      type: "Body1.OauthServiceTypeEnum"
    },
    {
      name: "serviceProxy",
      baseName: "serviceProxy",
      type: "ServiceProxyData"
    },
    {
      name: "actionProxy",
      baseName: "actionProxy",
      type: "ActionProxyData"
    },
    {
      name: "_public",
      baseName: "public",
      type: "boolean"
    },
    {
      name: "proxies",
      baseName: "proxies",
      type: "Proxies"
    },
    {
      name: "templateType",
      baseName: "templateType",
      type: "TemplateType"
    },
    {
      name: "triggers",
      baseName: "triggers",
      type: "Triggers"
    },
    {
      name: "services",
      baseName: "services",
      type: "Services"
    },
    {
      name: "actions",
      baseName: "actions",
      type: "Actions"
    },
    {
      name: "osType",
      baseName: "osType",
      type: "OsType"
    }
  ];

  static getAttributeTypeMap() {
    return Body1.attributeTypeMap;
  }
}

export namespace Body1 {
  export enum OauthServiceTypeEnum {
    Oauth = <any>"oauth"
  }
}
export class Body2 {
  "appletId": string;
  /**
   * イイネ！の数の増減値
   */
  "changeNum": number;

  static discriminator = undefined;

  static attributeTypeMap: Array<{
    name: string;
    baseName: string;
    type: string;
  }> = [
    {
      name: "appletId",
      baseName: "appletId",
      type: "string"
    },
    {
      name: "changeNum",
      baseName: "changeNum",
      type: "number"
    }
  ];

  static getAttributeTypeMap() {
    return Body2.attributeTypeMap;
  }
}

export class Body3 {
  "appletId": string;
  "num"?: number;

  static discriminator = undefined;

  static attributeTypeMap: Array<{
    name: string;
    baseName: string;
    type: string;
  }> = [
    {
      name: "appletId",
      baseName: "appletId",
      type: "string"
    },
    {
      name: "num",
      baseName: "num",
      type: "number"
    }
  ];

  static getAttributeTypeMap() {
    return Body3.attributeTypeMap;
  }
}

export class Body4 {
  "appletId": string;
  "status": boolean;

  static discriminator = undefined;

  static attributeTypeMap: Array<{
    name: string;
    baseName: string;
    type: string;
  }> = [
    {
      name: "appletId",
      baseName: "appletId",
      type: "string"
    },
    {
      name: "status",
      baseName: "status",
      type: "boolean"
    }
  ];

  static getAttributeTypeMap() {
    return Body4.attributeTypeMap;
  }
}

export class Body5 {
  "appletId": string;
  "status"?: boolean;

  static discriminator = undefined;

  static attributeTypeMap: Array<{
    name: string;
    baseName: string;
    type: string;
  }> = [
    {
      name: "appletId",
      baseName: "appletId",
      type: "string"
    },
    {
      name: "status",
      baseName: "status",
      type: "boolean"
    }
  ];

  static getAttributeTypeMap() {
    return Body5.attributeTypeMap;
  }
}

export class Body6 {
  "appletId": string;
  "status": Body6.StatusEnum;
  "message"?: string;

  static discriminator = undefined;

  static attributeTypeMap: Array<{
    name: string;
    baseName: string;
    type: string;
  }> = [
    {
      name: "appletId",
      baseName: "appletId",
      type: "string"
    },
    {
      name: "status",
      baseName: "status",
      type: "Body6.StatusEnum"
    },
    {
      name: "message",
      baseName: "message",
      type: "string"
    }
  ];

  static getAttributeTypeMap() {
    return Body6.attributeTypeMap;
  }
}

export namespace Body6 {
  export enum StatusEnum {
    Published = <any>"published",
    WaitingReview = <any>"waiting_review",
    Rejected = <any>"rejected",
    Deleted = <any>"deleted",
    Testing = <any>"testing"
  }
}
export class Body7 {
  "appletId": string;
  "status": Body7.StatusEnum;
  "message"?: string;

  static discriminator = undefined;

  static attributeTypeMap: Array<{
    name: string;
    baseName: string;
    type: string;
  }> = [
    {
      name: "appletId",
      baseName: "appletId",
      type: "string"
    },
    {
      name: "status",
      baseName: "status",
      type: "Body7.StatusEnum"
    },
    {
      name: "message",
      baseName: "message",
      type: "string"
    }
  ];

  static getAttributeTypeMap() {
    return Body7.attributeTypeMap;
  }
}

export namespace Body7 {
  export enum StatusEnum {
    Published = <any>"published",
    WaitingReview = <any>"waiting_review",
    Rejected = <any>"rejected",
    Deleted = <any>"deleted",
    Testing = <any>"testing"
  }
}
export class Body8 {
  "name"?: I18nObject;
  "description"?: I18nObject;
  "templateType"?: Body8.TemplateTypeEnum;
  "triggers"?: number;
  "services"?: number;
  "actions"?: number;
  "input"?: TemplateInputRequired;
  "output"?: TemplateOutputRequired;
  "wirings"?: AppletWirings;
  "templatePreferences"?: AppletPreferences;

  static discriminator = undefined;

  static attributeTypeMap: Array<{
    name: string;
    baseName: string;
    type: string;
  }> = [
    {
      name: "name",
      baseName: "name",
      type: "I18nObject"
    },
    {
      name: "description",
      baseName: "description",
      type: "I18nObject"
    },
    {
      name: "templateType",
      baseName: "templateType",
      type: "Body8.TemplateTypeEnum"
    },
    {
      name: "triggers",
      baseName: "triggers",
      type: "number"
    },
    {
      name: "services",
      baseName: "services",
      type: "number"
    },
    {
      name: "actions",
      baseName: "actions",
      type: "number"
    },
    {
      name: "input",
      baseName: "input",
      type: "TemplateInputRequired"
    },
    {
      name: "output",
      baseName: "output",
      type: "TemplateOutputRequired"
    },
    {
      name: "wirings",
      baseName: "wirings",
      type: "AppletWirings"
    },
    {
      name: "templatePreferences",
      baseName: "templatePreferences",
      type: "AppletPreferences"
    }
  ];

  static getAttributeTypeMap() {
    return Body8.attributeTypeMap;
  }
}

export namespace Body8 {
  export enum TemplateTypeEnum {
    ServiceParallel = <any>"serviceParallel",
    ServiceSerial = <any>"serviceSerial",
    ServiceExclusive = <any>"serviceExclusive"
  }
}

export class Body9 {
  "notificationToken": string;
  "appId": string;
  "vendorId": VendorId;
  "osType": string;

  static discriminator: string | undefined = undefined;

  static attributeTypeMap: Array<{
    name: string;
    baseName: string;
    type: string;
  }> = [
    {
      name: "notificationToken",
      baseName: "notificationToken",
      type: "string"
    },
    {
      name: "appId",
      baseName: "appId",
      type: "string"
    },
    {
      name: "osType",
      baseName: "osType",
      type: "string"
    }
  ];

  static getAttributeTypeMap() {
    return Body9.attributeTypeMap;
  }
}

export class Body10 {
  "vendorId": VendorId;
  "appletId": string;
  /**
   * alertメッセージ
   */
  "alert"?: string;
  /**
   * バッジとして表示する数
   */
  "badge"?: number;
  /**
   * 音声を指定
   */
  "sound"?: string;
  /**
   * trueを指定した時、Silent Remote Notificationとなる false指定 or 存在しない時は通常のRemote Notificationとなる trueの場合, alert, badge, soundは指定しないこと
   */
  "contentAvailable"?: boolean;
  /**
   * push通知再送のタイムアウト時刻 現在時刻からの秒数を指定
   */
  "expiresAt"?: number;
  /**
   * notificationのプライオリティを指定する. 5 or 10のみ指定可能
   */
  "priority"?: number;
  /**
   * 送信するデータ. 任意のJSON
   */
  "data"?: any;

  static discriminator: string | undefined = undefined;

  static attributeTypeMap: Array<{
    name: string;
    baseName: string;
    type: string;
  }> = [
    {
      name: "alert",
      baseName: "alert",
      type: "string"
    },
    {
      name: "badge",
      baseName: "badge",
      type: "number"
    },
    {
      name: "sound",
      baseName: "sound",
      type: "string"
    },
    {
      name: "contentAvailable",
      baseName: "contentAvailable",
      type: "boolean"
    },
    {
      name: "expiresAt",
      baseName: "expiresAt",
      type: "number"
    },
    {
      name: "priority",
      baseName: "priority",
      type: "number"
    },
    {
      name: "data",
      baseName: "data",
      type: "any"
    }
  ];

  static getAttributeTypeMap() {
    return Body10.attributeTypeMap;
  }
}

/**
 * CategoryのIDとして用いられる。
 */
export class CategoryId {
  static discriminator = undefined;

  static attributeTypeMap: Array<{
    name: string;
    baseName: string;
    type: string;
  }> = [];

  static getAttributeTypeMap() {
    return CategoryId.attributeTypeMap;
  }
}

export class Compatible extends Array<AppletInfoCompatible> {
  static discriminator = undefined;
}

/**
 * DeviceTypeのIDとして用いられる。
 */
export class DeviceTypeId {
  static discriminator = undefined;

  static attributeTypeMap: Array<{
    name: string;
    baseName: string;
    type: string;
  }> = [];

  static getAttributeTypeMap() {
    return DeviceTypeId.attributeTypeMap;
  }
}

/**
 * 言語毎の文言を指定できるオブジェクト。
 */
export class I18nObject {
  static discriminator = undefined;

  static attributeTypeMap: Array<{
    name: string;
    baseName: string;
    type: string;
  }> = [];

  static getAttributeTypeMap() {
    return I18nObject.attributeTypeMap;
  }
}

export class InlineResponse200 {
  /**
   * AppletWholeInfoのリスト
   */
  "applets"?: Array<AppletWholeInfo>;

  static discriminator = undefined;

  static attributeTypeMap: Array<{
    name: string;
    baseName: string;
    type: string;
  }> = [
    {
      name: "applets",
      baseName: "applets",
      type: "Array<AppletWholeInfo>"
    }
  ];

  static getAttributeTypeMap() {
    return InlineResponse200.attributeTypeMap;
  }
}

export class InlineResponse2001 {
  "appletTemplate"?: Array<AppletTemplate>;

  static discriminator = undefined;

  static attributeTypeMap: Array<{
    name: string;
    baseName: string;
    type: string;
  }> = [
    {
      name: "appletTemplate",
      baseName: "appletTemplate",
      type: "Array<AppletTemplate>"
    }
  ];

  static getAttributeTypeMap() {
    return InlineResponse2001.attributeTypeMap;
  }
}

/**
 * 404 Not Foundとともに返却されるエラーオブジェクト。 指定されたリソースが存在しなかった場合にこのエラーとなる。
 */
export class NotFound {
  static discriminator = undefined;

  static attributeTypeMap: Array<{
    name: string;
    baseName: string;
    type: string;
  }> = [];

  static getAttributeTypeMap() {
    return NotFound.attributeTypeMap;
  }
}

/**
 * blockが動作する対象スマホOS
 */
export class OsType {
  static discriminator = undefined;

  static attributeTypeMap: Array<{
    name: string;
    baseName: string;
    type: string;
  }> = [];

  static getAttributeTypeMap() {
    return OsType.attributeTypeMap;
  }
}

/**
 * Applet実行時に必要となるクライアントOSのパーミッションリスト Appletに含まれるBlockのパーミッションリストを結合したもの iOSとAndroidでパーミッションが必要となるものに差異があるため、各クライアントOS毎に定義している
 */
export class PermissionList {
  "ios"?: Array<PermissionList.IosEnum>;
  "android"?: Array<PermissionList.AndroidEnum>;

  static discriminator = undefined;

  static attributeTypeMap: Array<{
    name: string;
    baseName: string;
    type: string;
  }> = [
    {
      name: "ios",
      baseName: "ios",
      type: "Array<PermissionList.IosEnum>"
    },
    {
      name: "android",
      baseName: "android",
      type: "Array<PermissionList.AndroidEnum>"
    }
  ];

  static getAttributeTypeMap() {
    return PermissionList.attributeTypeMap;
  }
}

export namespace PermissionList {
  export enum IosEnum {
    Location = <any>"location",
    MediaLibrary = <any>"mediaLibrary"
  }
  export enum AndroidEnum {
    Location = <any>"location",
    MediaStore = <any>"mediaStore"
  }
}
/**
 * 外部APIで必要となる情報を入力
 */
export class Proxies extends null<String, ServiceProxyData> {
  static discriminator = undefined;

  static attributeTypeMap: Array<{
    name: string;
    baseName: string;
    type: string;
  }> = [];

  static getAttributeTypeMap() {
    return super.getAttributeTypeMap().concat(Proxies.attributeTypeMap);
  }
}

/**
 * ServiceProxyの情報。
 */
export class ServiceProxyData {
  /**
   * Blockで使用するServiceProxyCoreの名前。
   */
  "service"?: string;
  /**
   * BlockCoreがOSから取得するデータのパラメータリスト。
   */
  "parameters"?: Array<ServiceProxyData.ParametersEnum>;
  "authType"?: AuthType;

  static discriminator = undefined;

  static attributeTypeMap: Array<{
    name: string;
    baseName: string;
    type: string;
  }> = [
    {
      name: "service",
      baseName: "service",
      type: "string"
    },
    {
      name: "parameters",
      baseName: "parameters",
      type: "Array<ServiceProxyData.ParametersEnum>"
    },
    {
      name: "authType",
      baseName: "authType",
      type: "AuthType"
    }
  ];

  static getAttributeTypeMap() {
    return ServiceProxyData.attributeTypeMap;
  }
}

export namespace ServiceProxyData {
  export enum ParametersEnum {
    Location = <any>"location"
  }
}
/**
 * Appletテンプレート利用時の2つ目以降のService Block IDの列 1つ目のTrigger Blockは\"service\"に指定されたものとし、2つ目以降をこの配列に格納 処理の優先順位がある場合、\"service\"に記載されたもの→配列に記載されたBlockの先頭から末尾の順となる
 */
export class Services extends Array<string> {
  static discriminator = undefined;
}

export class Template {
  "id": string;
  "name": I18nObject;
  "description"?: I18nObject;
  "templateType": Template.TemplateTypeEnum;
  "triggers": number;
  "services": number;
  "actions": number;
  "input"?: TemplateInputRequired;
  "output"?: TemplateOutputRequired;
  "wirings": AppletWirings;
  "templatePreferences"?: AppletPreferences;

  static discriminator = undefined;

  static attributeTypeMap: Array<{
    name: string;
    baseName: string;
    type: string;
  }> = [
    {
      name: "id",
      baseName: "id",
      type: "string"
    },
    {
      name: "name",
      baseName: "name",
      type: "I18nObject"
    },
    {
      name: "description",
      baseName: "description",
      type: "I18nObject"
    },
    {
      name: "templateType",
      baseName: "templateType",
      type: "Template.TemplateTypeEnum"
    },
    {
      name: "triggers",
      baseName: "triggers",
      type: "number"
    },
    {
      name: "services",
      baseName: "services",
      type: "number"
    },
    {
      name: "actions",
      baseName: "actions",
      type: "number"
    },
    {
      name: "input",
      baseName: "input",
      type: "TemplateInputRequired"
    },
    {
      name: "output",
      baseName: "output",
      type: "TemplateOutputRequired"
    },
    {
      name: "wirings",
      baseName: "wirings",
      type: "AppletWirings"
    },
    {
      name: "templatePreferences",
      baseName: "templatePreferences",
      type: "AppletPreferences"
    }
  ];

  static getAttributeTypeMap() {
    return Template.attributeTypeMap;
  }
}

export namespace Template {
  export enum TemplateTypeEnum {
    ServiceParallel = <any>"serviceParallel",
    ServiceSerial = <any>"serviceSerial",
    ServiceExclusive = <any>"serviceExclusive"
  }
}
export class TemplateInputRequired {
  /**
   * テンプレートで利用できるservcie Blockに要求するinputの型を定義する
   */
  "service"?: string;
  /**
   * テンプレートで利用できるaction Blockに要求するinputの型を定義する
   */
  "action"?: string;

  static discriminator = undefined;

  static attributeTypeMap: Array<{
    name: string;
    baseName: string;
    type: string;
  }> = [
    {
      name: "service",
      baseName: "service",
      type: "string"
    },
    {
      name: "action",
      baseName: "action",
      type: "string"
    }
  ];

  static getAttributeTypeMap() {
    return TemplateInputRequired.attributeTypeMap;
  }
}

export class TemplateOutputRequired {
  /**
   * テンプレートで利用できるtrigger Blockに要求するoutputの型を定義する
   */
  "trigger"?: string;
  /**
   * テンプレートで利用できるservcie Blockに要求するoutputの型を定義する
   */
  "service"?: string;

  static discriminator = undefined;

  static attributeTypeMap: Array<{
    name: string;
    baseName: string;
    type: string;
  }> = [
    {
      name: "trigger",
      baseName: "trigger",
      type: "string"
    },
    {
      name: "service",
      baseName: "service",
      type: "string"
    }
  ];

  static getAttributeTypeMap() {
    return TemplateOutputRequired.attributeTypeMap;
  }
}

/**
 * Appletテンプレートの種類 BlockTypeがおなじものをどう実行するかの定義
 */
export class TemplateType {
  static discriminator = undefined;

  static attributeTypeMap: Array<{
    name: string;
    baseName: string;
    type: string;
  }> = [];

  static getAttributeTypeMap() {
    return TemplateType.attributeTypeMap;
  }
}

/**
 * ToolのIDとして用いられる。
 */
export class ToolId {
  static discriminator = undefined;

  static attributeTypeMap: Array<{
    name: string;
    baseName: string;
    type: string;
  }> = [];

  static getAttributeTypeMap() {
    return ToolId.attributeTypeMap;
  }
}

/**
 * Appletテンプレート利用時の2つ目以降のTrigger Block IDの列 1つ目のTrigger Blockは\"trigger\"に指定されたものとし、2つ目以降をこの配列に格納 処理の優先順位がある場合、\"trigger\"に記載されたもの→配列に記載されたBlockの先頭から末尾の順となる
 */
export class Triggers extends Array<string> {
  static discriminator = undefined;
}

/**
 * 401 Unauthorizedとともに返却されるエラーオブジェクト。 その他、Dodaiからエラーレスポンスが帰ってきた場合も該当する。 エラー内容は現状では正規化されてはいないが、正規化する場合はDodaiのエラーレスポンス形式に合わせる。
 */
export class Unauthorized {
  static discriminator = undefined;

  static attributeTypeMap: Array<{
    name: string;
    baseName: string;
    type: string;
  }> = [];

  static getAttributeTypeMap() {
    return Unauthorized.attributeTypeMap;
  }
}

/**
 * VendorのIDとして用いられる。
 */
export class VendorId {
  static discriminator = undefined;

  static attributeTypeMap: Array<{
    name: string;
    baseName: string;
    type: string;
  }> = [];

  static getAttributeTypeMap() {
    return VendorId.attributeTypeMap;
  }
}

let enumsMap: { [index: string]: any } = {
  "ActionProxyData.ParametersEnum": ActionProxyData.ParametersEnum,
  "Applet.OauthServiceTypeEnum": Applet.OauthServiceTypeEnum,
  "AppletInfo.StoreStatusEnum": AppletInfo.StoreStatusEnum,
  "AppletStoreStatus.StatusEnum": AppletStoreStatus.StatusEnum,
  "Body.OauthServiceTypeEnum": Body.OauthServiceTypeEnum,
  "Body1.OauthServiceTypeEnum": Body1.OauthServiceTypeEnum,
  "Body6.StatusEnum": Body6.StatusEnum,
  "Body7.StatusEnum": Body7.StatusEnum,
  "Body8.TemplateTypeEnum": Body8.TemplateTypeEnum,
  "PermissionList.IosEnum": PermissionList.IosEnum,
  "PermissionList.AndroidEnum": PermissionList.AndroidEnum,
  "ServiceProxyData.ParametersEnum": ServiceProxyData.ParametersEnum,
  "Template.TemplateTypeEnum": Template.TemplateTypeEnum
};

let typeMap: { [index: string]: any } = {
  ActionProxyData: ActionProxyData,
  Actions: Actions,
  Applet: Applet,
  AppletDownloadNum: AppletDownloadNum,
  AppletGoodNum: AppletGoodNum,
  AppletInfo: AppletInfo,
  AppletInfoCompatible: AppletInfoCompatible,
  AppletPreferences: AppletPreferences,
  AppletPublicStatus: AppletPublicStatus,
  AppletStoreStatus: AppletStoreStatus,
  AppletTemplate: AppletTemplate,
  AppletVersion: AppletVersion,
  AppletWholeInfo: AppletWholeInfo,
  AppletWiringSource: AppletWiringSource,
  AppletWirings: AppletWirings,
  AuthType: AuthType,
  BadRequest: BadRequest,
  Body: Body,
  Body1: Body1,
  Body2: Body2,
  Body3: Body3,
  Body4: Body4,
  Body5: Body5,
  Body6: Body6,
  Body7: Body7,
  Body8: Body8,
  CategoryId: CategoryId,
  Compatible: Compatible,
  DeviceTypeId: DeviceTypeId,
  I18nObject: I18nObject,
  InlineResponse200: InlineResponse200,
  InlineResponse2001: InlineResponse2001,
  NotFound: NotFound,
  OsType: OsType,
  PermissionList: PermissionList,
  Proxies: Proxies,
  ServiceProxyData: ServiceProxyData,
  Services: Services,
  Template: Template,
  TemplateInputRequired: TemplateInputRequired,
  TemplateOutputRequired: TemplateOutputRequired,
  TemplateType: TemplateType,
  ToolId: ToolId,
  Triggers: Triggers,
  Unauthorized: Unauthorized,
  VendorId: VendorId
};

export interface Authentication {
  /**
   * Apply authentication settings to header and query params.
   */
  applyToRequest(requestOptions: localVarRequest.Options): void;
}

export class HttpBasicAuth implements Authentication {
  public username: string = "";
  public password: string = "";

  applyToRequest(requestOptions: localVarRequest.Options): void {
    requestOptions.auth = {
      username: this.username,
      password: this.password
    };
  }
}

export class ApiKeyAuth implements Authentication {
  public apiKey: string = "";

  constructor(private location: string, private paramName: string) {}

  applyToRequest(requestOptions: localVarRequest.Options): void {
    if (this.location == "query") {
      (<any>requestOptions.qs)[this.paramName] = this.apiKey;
    } else if (
      this.location == "header" &&
      requestOptions &&
      requestOptions.headers
    ) {
      requestOptions.headers[this.paramName] = this.apiKey;
    }
  }
}

export class OAuth implements Authentication {
  public accessToken: string = "";

  applyToRequest(requestOptions: localVarRequest.Options): void {
    if (requestOptions && requestOptions.headers) {
      requestOptions.headers["Authorization"] = "Bearer " + this.accessToken;
    }
  }
}

export class VoidAuth implements Authentication {
  public username: string = "";
  public password: string = "";

  applyToRequest(_: localVarRequest.Options): void {
    // Do nothing
  }
}

export enum DefaultApiApiKeys {
  JWTToken
}

export class DefaultApi {
  protected _basePath = defaultBasePath;
  protected defaultHeaders: any = {};
  protected _useQuerystring: boolean = false;

  protected authentications = {
    default: <Authentication>new VoidAuth(),
    JWTToken: new ApiKeyAuth("header", "Authorization")
  };

  constructor(basePath?: string);
  constructor(
    basePathOrUsername: string,
    password?: string,
    basePath?: string
  ) {
    if (password) {
      if (basePath) {
        this.basePath = basePath;
      }
    } else {
      if (basePathOrUsername) {
        this.basePath = basePathOrUsername;
      }
    }
  }

  set useQuerystring(value: boolean) {
    this._useQuerystring = value;
  }

  set basePath(basePath: string) {
    this._basePath = basePath;
  }

  get basePath() {
    return this._basePath;
  }

  public setDefaultAuthentication(auth: Authentication) {
    this.authentications.default = auth;
  }

  public setApiKey(key: DefaultApiApiKeys, value: string) {
    (this.authentications as any)[DefaultApiApiKeys[key]].apiKey = value;
  }
  /**
   * プッシュ通知のNotification Tokenの登録を行う.
   * @param body
   * @param {*} [options] Override http request options.
   */
  public registerNotificationToken(
    body: Body9,
    options: any = {}
  ): Promise<{ response: http.IncomingMessage; body?: any }> {
    const localVarPath = this.basePath + "/push/notificationToken";
    let localVarQueryParameters: any = {};
    let localVarHeaderParams: any = (<any>Object).assign(
      {},
      this.defaultHeaders
    );
    let localVarFormParams: any = {};

    // verify required parameter 'body' is not null or undefined
    if (body === null || body === undefined) {
      throw new Error(
        "Required parameter body was null or undefined when calling registerNotificationToken."
      );
    }

    (<any>Object).assign(localVarHeaderParams, options.headers);

    let localVarUseFormData = false;

    let localVarRequestOptions: localVarRequest.Options = {
      method: "POST",
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true,
      body: ObjectSerializer.serialize(body, "Body9")
    };

    this.authentications.JWTToken.applyToRequest(localVarRequestOptions);

    this.authentications.default.applyToRequest(localVarRequestOptions);

    if (Object.keys(localVarFormParams).length) {
      if (localVarUseFormData) {
        (<any>localVarRequestOptions).formData = localVarFormParams;
      } else {
        localVarRequestOptions.form = localVarFormParams;
      }
    }
    return new Promise<{ response: http.IncomingMessage; body?: any }>(
      (resolve, reject) => {
        localVarRequest(localVarRequestOptions, (error, response, body) => {
          if (error) {
            reject(error);
          } else {
            if (
              response.statusCode &&
              response.statusCode >= 200 &&
              response.statusCode <= 299
            ) {
              resolve({ response: response, body: body });
            } else {
              reject({ response: response, body: body });
            }
          }
        });
      }
    );
  }
  /**
   * ID指定したAppletを削除する。
   * @param id
   * @param {*} [options] Override http request options.
   */
  public deleteApplet(
    id: string
  ): Promise<{ response: http.IncomingMessage; body?: any }> {
    const localVarPath =
      this.basePath +
      "/applets/{id}".replace("{" + "id" + "}", encodeURIComponent(String(id)));
      console.log(localVarPath)
    let localVarQueryParameters: any = {};
    let localVarHeaderParams: any = (<any>Object).assign(
      {},
      this.defaultHeaders
    );
    let localVarFormParams: any = {};

    // verify required parameter 'id' is not null or undefined
    if (id === null || id === undefined) {
      throw new Error(
        "Required parameter id was null or undefined when calling deleteApplet."
      );
    }

    let localVarUseFormData = false;

    let localVarRequestOptions: localVarRequest.Options = {
      method: "DELETE",
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true
    };

    this.authentications.JWTToken.applyToRequest(localVarRequestOptions);

    this.authentications.default.applyToRequest(localVarRequestOptions);

    if (Object.keys(localVarFormParams).length) {
      if (localVarUseFormData) {
        (<any>localVarRequestOptions).formData = localVarFormParams;
      } else {
        localVarRequestOptions.form = localVarFormParams;
      }
    }
    return new Promise<{ response: http.IncomingMessage; body?: any }>(
      (resolve, reject) => {
        localVarRequest(localVarRequestOptions, (error, response, body) => {
          if (error) {
            reject(error);
          } else {
            if (
              response.statusCode &&
              response.statusCode >= 200 &&
              response.statusCode <= 299
            ) {
              resolve({ response: response, body: body });
            } else {
              reject({ response: response, body: body });
            }
          }
        });
      }
    );
  }
  /**
   * ID指定したAppletテンプレートを削除する security modelは要検討。
   * @param id
   */
  public deleteTemplate(
    id: string
  ): Promise<{ response: http.IncomingMessage; body?: any }> {
    const localVarPath =
      this.basePath +
      "/templates/{id}".replace(
        "{" + "id" + "}",
        encodeURIComponent(String(id))
      );
    let localVarQueryParameters: any = {};
    let localVarHeaderParams: any = (<any>Object).assign(
      {},
      this.defaultHeaders
    );
    let localVarFormParams: any = {};

    // verify required parameter 'id' is not null or undefined
    if (id === null || id === undefined) {
      throw new Error(
        "Required parameter id was null or undefined when calling deleteTemplate."
      );
    }

    let localVarUseFormData = false;

    let localVarRequestOptions: localVarRequest.Options = {
      method: "DELETE",
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true
    };

    this.authentications.JWTToken.applyToRequest(localVarRequestOptions);

    this.authentications.default.applyToRequest(localVarRequestOptions);

    if (Object.keys(localVarFormParams).length) {
      if (localVarUseFormData) {
        (<any>localVarRequestOptions).formData = localVarFormParams;
      } else {
        localVarRequestOptions.form = localVarFormParams;
      }
    }
    return new Promise<{ response: http.IncomingMessage; body?: any }>(
      (resolve, reject) => {
        localVarRequest(localVarRequestOptions, (error, response, body) => {
          if (error) {
            reject(error);
          } else {
            if (
              response.statusCode &&
              response.statusCode >= 200 &&
              response.statusCode <= 299
            ) {
              resolve({ response: response, body: body });
            } else {
              reject({ response: response, body: body });
            }
          }
        });
      }
    );
  }
  /**
   * ID指定したAppletを取得する。 (SDK向けAPI)
   * @param id
   * @param deviceId 対象とするデバイス種別をIDで指定する。(複数指定可能) レスポンスには、_指定したデバイスで実行可能なAppletのみ_が含まれる。
   * @param osType blockが動作する対象スマホOS
   */
  public getApplet(
    id: string,
    deviceId?: Array<string>,
    osType?: "iOS" | "Android" | "none"
  ): Promise<{ response: http.IncomingMessage; body: Applet }> {
    const localVarPath =
      this.basePath +
      "/applets/{id}".replace("{" + "id" + "}", encodeURIComponent(String(id)));
    let localVarQueryParameters: any = {};
    let localVarHeaderParams: any = (<any>Object).assign(
      {},
      this.defaultHeaders
    );
    let localVarFormParams: any = {};

    // verify required parameter 'id' is not null or undefined
    if (id === null || id === undefined) {
      throw new Error(
        "Required parameter id was null or undefined when calling getApplet."
      );
    }

    if (deviceId !== undefined) {
      localVarQueryParameters["deviceId"] = ObjectSerializer.serialize(
        deviceId,
        "Array<string>"
      );
    }

    if (osType !== undefined) {
      localVarQueryParameters["osType"] = ObjectSerializer.serialize(
        osType,
        "'iOS' | 'Android' | 'none'"
      );
    }

    let localVarUseFormData = false;

    let localVarRequestOptions: localVarRequest.Options = {
      method: "GET",
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true
    };

    this.authentications.JWTToken.applyToRequest(localVarRequestOptions);

    this.authentications.default.applyToRequest(localVarRequestOptions);

    if (Object.keys(localVarFormParams).length) {
      if (localVarUseFormData) {
        (<any>localVarRequestOptions).formData = localVarFormParams;
      } else {
        localVarRequestOptions.form = localVarFormParams;
      }
    }
    return new Promise<{ response: http.IncomingMessage; body: Applet }>(
      (resolve, reject) => {
        localVarRequest(localVarRequestOptions, (error, response, body) => {
          if (error) {
            reject(error);
          } else {
            body = ObjectSerializer.deserialize(body, "Applet");
            if (
              response.statusCode &&
              response.statusCode >= 200 &&
              response.statusCode <= 299
            ) {
              resolve({ response: response, body: body });
            } else {
              reject({ response: response, body: body });
            }
          }
        });
      }
    );
  }
  /**
   * ID指定したAppletのダウンロード数を取得する。
   * @param appletId
   */
  public getAppletDownloadNum(
    appletId: string
  ): Promise<{ response: http.IncomingMessage; body: AppletDownloadNum }> {
    const localVarPath = this.basePath + "/appletDownloadNum";
    let localVarQueryParameters: any = {};
    let localVarHeaderParams: any = (<any>Object).assign(
      {},
      this.defaultHeaders
    );
    let localVarFormParams: any = {};

    // verify required parameter 'appletId' is not null or undefined
    if (appletId === null || appletId === undefined) {
      throw new Error(
        "Required parameter appletId was null or undefined when calling getAppletDownloadNum."
      );
    }

    if (appletId !== undefined) {
      localVarQueryParameters["appletId"] = ObjectSerializer.serialize(
        appletId,
        "string"
      );
    }

    let localVarUseFormData = false;

    let localVarRequestOptions: localVarRequest.Options = {
      method: "GET",
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true
    };

    this.authentications.JWTToken.applyToRequest(localVarRequestOptions);

    this.authentications.default.applyToRequest(localVarRequestOptions);

    if (Object.keys(localVarFormParams).length) {
      if (localVarUseFormData) {
        (<any>localVarRequestOptions).formData = localVarFormParams;
      } else {
        localVarRequestOptions.form = localVarFormParams;
      }
    }
    return new Promise<{
      response: http.IncomingMessage;
      body: AppletDownloadNum;
    }>((resolve, reject) => {
      localVarRequest(localVarRequestOptions, (error, response, body) => {
        if (error) {
          reject(error);
        } else {
          body = ObjectSerializer.deserialize(body, "AppletDownloadNum");
          if (
            response.statusCode &&
            response.statusCode >= 200 &&
            response.statusCode <= 299
          ) {
            resolve({ response: response, body: body });
          } else {
            reject({ response: response, body: body });
          }
        }
      });
    });
  }
  /**
   * ID指定したAppletのイイネ！の数を取得する。
   * @param appletId
   */
  public getAppletGoodNum(
    appletId: string
  ): Promise<{ response: http.IncomingMessage; body: AppletGoodNum }> {
    const localVarPath = this.basePath + "/appletGoodNum";
    let localVarQueryParameters: any = {};
    let localVarHeaderParams: any = (<any>Object).assign(
      {},
      this.defaultHeaders
    );
    let localVarFormParams: any = {};

    // verify required parameter 'appletId' is not null or undefined
    if (appletId === null || appletId === undefined) {
      throw new Error(
        "Required parameter appletId was null or undefined when calling getAppletGoodNum."
      );
    }

    if (appletId !== undefined) {
      localVarQueryParameters["appletId"] = ObjectSerializer.serialize(
        appletId,
        "string"
      );
    }

    let localVarUseFormData = false;

    let localVarRequestOptions: localVarRequest.Options = {
      method: "GET",
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true
    };

    this.authentications.JWTToken.applyToRequest(localVarRequestOptions);

    this.authentications.default.applyToRequest(localVarRequestOptions);

    if (Object.keys(localVarFormParams).length) {
      if (localVarUseFormData) {
        (<any>localVarRequestOptions).formData = localVarFormParams;
      } else {
        localVarRequestOptions.form = localVarFormParams;
      }
    }
    return new Promise<{ response: http.IncomingMessage; body: AppletGoodNum }>(
      (resolve, reject) => {
        localVarRequest(localVarRequestOptions, (error, response, body) => {
          if (error) {
            reject(error);
          } else {
            body = ObjectSerializer.deserialize(body, "AppletGoodNum");
            if (
              response.statusCode &&
              response.statusCode >= 200 &&
              response.statusCode <= 299
            ) {
              resolve({ response: response, body: body });
            } else {
              reject({ response: response, body: body });
            }
          }
        });
      }
    );
  }
  /**
   * ID指定したAppletのAppletPublicStatusを取得する。
   * @param appletId
   */
  public getAppletPublicStatus(
    appletId: string
  ): Promise<{ response: http.IncomingMessage; body: AppletPublicStatus }> {
    const localVarPath = this.basePath + "/appletPublicStatus";
    let localVarQueryParameters: any = {};
    let localVarHeaderParams: any = (<any>Object).assign(
      {},
      this.defaultHeaders
    );
    let localVarFormParams: any = {};

    // verify required parameter 'appletId' is not null or undefined
    if (appletId === null || appletId === undefined) {
      throw new Error(
        "Required parameter appletId was null or undefined when calling getAppletPublicStatus."
      );
    }

    if (appletId !== undefined) {
      localVarQueryParameters["appletId"] = ObjectSerializer.serialize(
        appletId,
        "string"
      );
    }

    let localVarUseFormData = false;

    let localVarRequestOptions: localVarRequest.Options = {
      method: "GET",
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true
    };

    this.authentications.JWTToken.applyToRequest(localVarRequestOptions);

    this.authentications.default.applyToRequest(localVarRequestOptions);

    if (Object.keys(localVarFormParams).length) {
      if (localVarUseFormData) {
        (<any>localVarRequestOptions).formData = localVarFormParams;
      } else {
        localVarRequestOptions.form = localVarFormParams;
      }
    }
    return new Promise<{
      response: http.IncomingMessage;
      body: AppletPublicStatus;
    }>((resolve, reject) => {
      localVarRequest(localVarRequestOptions, (error, response, body) => {
        if (error) {
          reject(error);
        } else {
          body = ObjectSerializer.deserialize(body, "AppletPublicStatus");
          if (
            response.statusCode &&
            response.statusCode >= 200 &&
            response.statusCode <= 299
          ) {
            resolve({ response: response, body: body });
          } else {
            reject({ response: response, body: body });
          }
        }
      });
    });
  }
  /**
   * ID指定したAppletの審査ステータスを取得する。
   * @param appletId
   */
  public getAppletStoreStatus(
    appletId: string
  ): Promise<{ response: http.IncomingMessage; body: AppletStoreStatus }> {
    const localVarPath = this.basePath + "/appletStoreStatus";
    let localVarQueryParameters: any = {};
    let localVarHeaderParams: any = (<any>Object).assign(
      {},
      this.defaultHeaders
    );
    let localVarFormParams: any = {};

    // verify required parameter 'appletId' is not null or undefined
    if (appletId === null || appletId === undefined) {
      throw new Error(
        "Required parameter appletId was null or undefined when calling getAppletStoreStatus."
      );
    }

    if (appletId !== undefined) {
      localVarQueryParameters["appletId"] = ObjectSerializer.serialize(
        appletId,
        "string"
      );
    }

    let localVarUseFormData = false;

    let localVarRequestOptions: localVarRequest.Options = {
      method: "GET",
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true
    };

    this.authentications.JWTToken.applyToRequest(localVarRequestOptions);

    this.authentications.default.applyToRequest(localVarRequestOptions);

    if (Object.keys(localVarFormParams).length) {
      if (localVarUseFormData) {
        (<any>localVarRequestOptions).formData = localVarFormParams;
      } else {
        localVarRequestOptions.form = localVarFormParams;
      }
    }
    return new Promise<{
      response: http.IncomingMessage;
      body: AppletStoreStatus;
    }>((resolve, reject) => {
      localVarRequest(localVarRequestOptions, (error, response, body) => {
        if (error) {
          reject(error);
        } else {
          body = ObjectSerializer.deserialize(body, "AppletStoreStatus");
          if (
            response.statusCode &&
            response.statusCode >= 200 &&
            response.statusCode <= 299
          ) {
            resolve({ response: response, body: body });
          } else {
            reject({ response: response, body: body });
          }
        }
      });
    });
  }
  /**
   * UserのApplet一覧を取得する。User keyで実行可能。 (AppletBuilder向けAPI)
   * @param storeStatus AppletStoreStatusの審査ステータスと一致するものを含む。 （主に、申請待ち一覧を取得する際に使用する）
   * @param publicStatus AppletPublicStatusの公開ステータスと一致するものを含む。
   */
  public getMyApplets(
    storeStatus?: "published" | "waiting_review" | "rejected" | "deleted",
    publicStatus?: boolean
  ): Promise<{ response: http.IncomingMessage; body: InlineResponse200 }> {
    const localVarPath = this.basePath + "/createownapplets";
    let localVarQueryParameters: any = {};
    let localVarHeaderParams: any = (<any>Object).assign(
      {},
      this.defaultHeaders
    );
    let localVarFormParams: any = {};

    if (storeStatus !== undefined) {
      localVarQueryParameters["storeStatus"] = ObjectSerializer.serialize(
        storeStatus,
        "'published' | 'waiting_review' | 'rejected' | 'deleted'"
      );
    }

    if (publicStatus !== undefined) {
      localVarQueryParameters["publicStatus"] = ObjectSerializer.serialize(
        publicStatus,
        "boolean"
      );
    }

    let localVarUseFormData = false;

    let localVarRequestOptions: localVarRequest.Options = {
      method: "GET",
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true
    };

    this.authentications.JWTToken.applyToRequest(localVarRequestOptions);

    this.authentications.default.applyToRequest(localVarRequestOptions);

    if (Object.keys(localVarFormParams).length) {
      if (localVarUseFormData) {
        (<any>localVarRequestOptions).formData = localVarFormParams;
      } else {
        localVarRequestOptions.form = localVarFormParams;
      }
    }
    return new Promise<{
      response: http.IncomingMessage;
      body: InlineResponse200;
    }>((resolve, reject) => {
      localVarRequest(localVarRequestOptions, (error, response, body) => {
        if (error) {
          reject(error);
        } else {
          body = ObjectSerializer.deserialize(body, "InlineResponse200");
          if (
            response.statusCode &&
            response.statusCode >= 200 &&
            response.statusCode <= 299
          ) {
            resolve({ response: response, body: body });
          } else {
            reject({ response: response, body: body });
          }
        }
      });
    });
  }
  /**
   * ID指定したAppletテンプレートを取得する。 security modelは要検討。
   * @param id
   */
  public getTemplate(
    id: string
  ): Promise<{ response: http.IncomingMessage; body: AppletTemplate }> {
    const localVarPath =
      this.basePath +
      "/templates/{id}".replace(
        "{" + "id" + "}",
        encodeURIComponent(String(id))
      );
    let localVarQueryParameters: any = {};
    let localVarHeaderParams: any = (<any>Object).assign(
      {},
      this.defaultHeaders
    );
    let localVarFormParams: any = {};

    // verify required parameter 'id' is not null or undefined
    if (id === null || id === undefined) {
      throw new Error(
        "Required parameter id was null or undefined when calling getTemplate."
      );
    }

    let localVarUseFormData = false;

    let localVarRequestOptions: localVarRequest.Options = {
      method: "GET",
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true
    };

    this.authentications.JWTToken.applyToRequest(localVarRequestOptions);

    this.authentications.default.applyToRequest(localVarRequestOptions);

    if (Object.keys(localVarFormParams).length) {
      if (localVarUseFormData) {
        (<any>localVarRequestOptions).formData = localVarFormParams;
      } else {
        localVarRequestOptions.form = localVarFormParams;
      }
    }
    return new Promise<{
      response: http.IncomingMessage;
      body: AppletTemplate;
    }>((resolve, reject) => {
      localVarRequest(localVarRequestOptions, (error, response, body) => {
        if (error) {
          reject(error);
        } else {
          body = ObjectSerializer.deserialize(body, "AppletTemplate");
          if (
            response.statusCode &&
            response.statusCode >= 200 &&
            response.statusCode <= 299
          ) {
            resolve({ response: response, body: body });
          } else {
            reject({ response: response, body: body });
          }
        }
      });
    });
  }
  /**
   * Applet一覧を取得する。 (Store向けAPI)
   * @param version Appletのバージョンを指定する。 レスポンスには、指定されたバージョン以降のAppletのみが含まれる。 Note: 単なる文字列として保持すると比較が不正確となるため、バージョンナンバーは整数値を X.Y.Z の形式で指定するものとする。 X、Y、Z は負の整数であってはならず、各数値の先頭に0を配置してはならない。 現在は未対応であるが、正確に比較しようとする場合、内部的には&#x60;{ major: integer, minor: integer, patch: integer }&#x60;として値を保持して整数比較するべき。
   * @param appletId AppletIDを指定する。(複数指定可能)
   * @param excludeAppletId Exclude applet ID(s) in get applets
   * @param toolId 対象とするToolのIDを完全一致で指定する。 レスポンスには、_指定した文字列に完全一致する&#x60;toolId&#x60;を持つAppletのみ_が含まれる。
   * @param categoryId 対象とするCategoryのIDを完全一致で指定する。 レスポンスには、_指定した文字列に完全一致する&#x60;categoryId&#x60;を持つAppletのみ_が含まれる。
   * @param deviceId 対象とするデバイス種別をIDで指定する。(複数指定可能) レスポンスには、_指定したデバイスで実行可能なAppletのみ_が含まれる。
   * @param vendorId 対象とするベンダーをIDで指定する。 レスポンスには、_指定したベンダーが開発・管理するAppletのみ_が含まれる。
   * @param storeStatus AppletStoreStatusの審査ステータスと一致するものを含む。 （主に、申請待ち一覧を取得する際に使用する）
   * @param publicStatus AppletPublicStatusの公開ステータスと一致するものを含む。
   * @param ownerId 対象とするオーナーをIDで指定する。(複数指定可能) レスポンスには、_指定したオーナーが所持するAppletのみ_が含まれる。
   * @param title Applets title
   * @param sortBy likeNum順あるいはDate順に並び替える。
   * @param limit データ数を限定する。
   * @param osType blockが動作する対象スマホOS
   */
  public listAdminApplets(
    version: string,
    appletId?: Array<string>,
    excludeAppletId?: Array<string>,
    toolId?: Array<string>,
    categoryId?: Array<string>,
    deviceId?: Array<string>,
    vendorId?: string,
    storeStatus?: "published" | "waiting_review" | "rejected" | "deleted",
    publicStatus?: boolean,
    ownerId?: Array<string>,
    title?: string,
    sortBy?: "likeNum" | "releaseDate",
    limit?: number,
    osType?: "iOS" | "Android" | "none"
  ): Promise<{ response: http.IncomingMessage; body: InlineResponse200 }> {
    const localVarPath = this.basePath + "/admin/applets";
    let localVarQueryParameters: any = {};
    let localVarHeaderParams: any = (<any>Object).assign(
      {},
      this.defaultHeaders
    );
    let localVarFormParams: any = {};

    // verify required parameter 'version' is not null or undefined
    if (version === null || version === undefined) {
      throw new Error(
        "Required parameter version was null or undefined when calling listAdminApplets."
      );
    }

    if (appletId !== undefined) {
      localVarQueryParameters["appletId"] = ObjectSerializer.serialize(
        appletId,
        "Array<string>"
      );
    }

    if (excludeAppletId !== undefined) {
      localVarQueryParameters["excludeAppletId"] = ObjectSerializer.serialize(
        excludeAppletId,
        "Array<string>"
      );
    }

    if (toolId !== undefined) {
      localVarQueryParameters["toolId"] = ObjectSerializer.serialize(
        toolId,
        "Array<string>"
      );
    }

    if (categoryId !== undefined) {
      localVarQueryParameters["categoryId"] = ObjectSerializer.serialize(
        categoryId,
        "Array<string>"
      );
    }

    if (deviceId !== undefined) {
      localVarQueryParameters["deviceId"] = ObjectSerializer.serialize(
        deviceId,
        "Array<string>"
      );
    }

    if (vendorId !== undefined) {
      localVarQueryParameters["vendorId"] = ObjectSerializer.serialize(
        vendorId,
        "string"
      );
    }

    if (version !== undefined) {
      localVarQueryParameters["version"] = ObjectSerializer.serialize(
        version,
        "string"
      );
    }

    if (storeStatus !== undefined) {
      localVarQueryParameters["storeStatus"] = ObjectSerializer.serialize(
        storeStatus,
        "'published' | 'waiting_review' | 'rejected' | 'deleted'"
      );
    }

    if (publicStatus !== undefined) {
      localVarQueryParameters["publicStatus"] = ObjectSerializer.serialize(
        publicStatus,
        "boolean"
      );
    }

    if (ownerId !== undefined) {
      localVarQueryParameters["ownerId"] = ObjectSerializer.serialize(
        ownerId,
        "Array<string>"
      );
    }

    if (title !== undefined) {
      localVarQueryParameters["title"] = ObjectSerializer.serialize(
        title,
        "string"
      );
    }

    if (sortBy !== undefined) {
      localVarQueryParameters["sortBy"] = ObjectSerializer.serialize(
        sortBy,
        "'likeNum' | 'releaseDate'"
      );
    }

    if (limit !== undefined) {
      localVarQueryParameters["limit"] = ObjectSerializer.serialize(
        limit,
        "number"
      );
    }

    if (osType !== undefined) {
      localVarQueryParameters["osType"] = ObjectSerializer.serialize(
        osType,
        "'iOS' | 'Android' | 'none'"
      );
    }

    let localVarUseFormData = false;

    let localVarRequestOptions: localVarRequest.Options = {
      method: "GET",
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true
    };

    this.authentications.default.applyToRequest(localVarRequestOptions);

    if (Object.keys(localVarFormParams).length) {
      if (localVarUseFormData) {
        (<any>localVarRequestOptions).formData = localVarFormParams;
      } else {
        localVarRequestOptions.form = localVarFormParams;
      }
    }
    return new Promise<{
      response: http.IncomingMessage;
      body: InlineResponse200;
    }>((resolve, reject) => {
      localVarRequest(localVarRequestOptions, (error, response, body) => {
        if (error) {
          reject(error);
        } else {
          body = ObjectSerializer.deserialize(body, "InlineResponse200");
          if (
            response.statusCode &&
            response.statusCode >= 200 &&
            response.statusCode <= 299
          ) {
            resolve({ response: response, body: body });
          } else {
            reject({ response: response, body: body });
          }
        }
      });
    });
  }
  /**
   * Applet一覧を取得する。 (Store向けAPI)
   * @param version Appletのバージョンを指定する。 レスポンスには、指定されたバージョン以降のAppletのみが含まれる。 Note: 単なる文字列として保持すると比較が不正確となるため、バージョンナンバーは整数値を X.Y.Z の形式で指定するものとする。 X、Y、Z は負の整数であってはならず、各数値の先頭に0を配置してはならない。 現在は未対応であるが、正確に比較しようとする場合、内部的には&#x60;{ major: integer, minor: integer, patch: integer }&#x60;として値を保持して整数比較するべき。
   * @param appletId AppletIDを指定する。(複数指定可能)
   * @param excludeAppletId Exclude applet ID(s) in get applets
   * @param toolId 対象とするToolのIDを完全一致で指定する。 レスポンスには、_指定した文字列に完全一致する&#x60;toolId&#x60;を持つAppletのみ_が含まれる。
   * @param categoryId 対象とするCategoryのIDを完全一致で指定する。 レスポンスには、_指定した文字列に完全一致する&#x60;categoryId&#x60;を持つAppletのみ_が含まれる。
   * @param deviceId 対象とするデバイス種別をIDで指定する。(複数指定可能) レスポンスには、_指定したデバイスで実行可能なAppletのみ_が含まれる。
   * @param vendorId 対象とするベンダーをIDで指定する。 レスポンスには、_指定したベンダーが開発・管理するAppletのみ_が含まれる。
   * @param storeStatus AppletStoreStatusの審査ステータスと一致するものを含む。 （主に、申請待ち一覧を取得する際に使用する）
   * @param publicStatus AppletPublicStatusの公開ステータスと一致するものを含む。
   * @param ownerId 対象とするオーナーをIDで指定する。(複数指定可能) レスポンスには、_指定したオーナーが所持するAppletのみ_が含まれる。
   * @param title Applets title
   * @param sortBy likeNum順あるいはDate順に並び替える。
   * @param limit データ数を限定する。
   * @param osType blockが動作する対象スマホOS
   */
  public listApplets(
    version: string,
    appletId?: Array<string>,
    excludeAppletId?: Array<string>,
    toolId?: Array<string>,
    categoryId?: Array<string>,
    deviceId?: Array<string>,
    vendorId?: string,
    storeStatus?: "published" | "waiting_review" | "rejected" | "deleted",
    publicStatus?: boolean,
    ownerId?: Array<string>,
    title?: string,
    sortBy?: "likeNum" | "releaseDate",
    limit?: number,
    osType?: "iOS" | "Android" | "none"
  ): Promise<{ response: http.IncomingMessage; body: InlineResponse200 }> {
    const localVarPath = this.basePath + "/applets";
    let localVarQueryParameters: any = {};
    let localVarHeaderParams: any = (<any>Object).assign(
      {},
      this.defaultHeaders
    );
    let localVarFormParams: any = {};

    // verify required parameter 'version' is not null or undefined
    if (version === null || version === undefined) {
      throw new Error(
        "Required parameter version was null or undefined when calling listApplets."
      );
    }

    if (appletId !== undefined) {
      localVarQueryParameters["appletId"] = appletId.join(",");
    }

    if (excludeAppletId !== undefined) {
      localVarQueryParameters["excludeAppletId"] = excludeAppletId.join(",");
    }

    if (toolId !== undefined) {
      localVarQueryParameters["toolId"] = toolId.join(",");
    }

    if (categoryId !== undefined) {
      localVarQueryParameters["categoryId"] = categoryId.join(",");
    }

    if (deviceId !== undefined) {
      localVarQueryParameters["deviceId"] = deviceId.join(",");
    }

    if (vendorId !== undefined) {
      localVarQueryParameters["vendorId"] = ObjectSerializer.serialize(
        vendorId,
        "string"
      );
    }

    if (version !== undefined) {
      localVarQueryParameters["version"] = ObjectSerializer.serialize(
        version,
        "string"
      );
    }

    if (storeStatus !== undefined) {
      localVarQueryParameters["storeStatus"] = ObjectSerializer.serialize(
        storeStatus,
        "'published' | 'waiting_review' | 'rejected' | 'deleted'"
      );
    }

    if (publicStatus !== undefined) {
      localVarQueryParameters["publicStatus"] = ObjectSerializer.serialize(
        publicStatus,
        "boolean"
      );
    }

    if (ownerId !== undefined) {
      localVarQueryParameters["ownerId"] = ownerId.join(",");
    }

    if (title !== undefined) {
      localVarQueryParameters["title"] = ObjectSerializer.serialize(
        title,
        "string"
      );
    }

    if (sortBy !== undefined) {
      localVarQueryParameters["sortBy"] = ObjectSerializer.serialize(
        sortBy,
        "'likeNum' | 'releaseDate'"
      );
    }

    if (limit !== undefined) {
      localVarQueryParameters["limit"] = ObjectSerializer.serialize(
        limit,
        "number"
      );
    }

    if (osType !== undefined) {
      localVarQueryParameters["osType"] = ObjectSerializer.serialize(
        osType,
        "'iOS' | 'Android' | 'none'"
      );
    }

    let localVarUseFormData = false;

    let localVarRequestOptions: localVarRequest.Options = {
      method: "GET",
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true
    };

    this.authentications.JWTToken.applyToRequest(localVarRequestOptions);

    this.authentications.default.applyToRequest(localVarRequestOptions);

    if (Object.keys(localVarFormParams).length) {
      if (localVarUseFormData) {
        (<any>localVarRequestOptions).formData = localVarFormParams;
      } else {
        localVarRequestOptions.form = localVarFormParams;
      }
    }
    return new Promise<{
      response: http.IncomingMessage;
      body: InlineResponse200;
    }>((resolve, reject) => {
      localVarRequest(localVarRequestOptions, (error, response, body) => {
        if (error) {
          reject(error);
        } else {
          body = ObjectSerializer.deserialize(body, "InlineResponse200");
          if (
            response.statusCode &&
            response.statusCode >= 200 &&
            response.statusCode <= 299
          ) {
            resolve({ response: response, body: body });
          } else {
            reject({ response: response, body: body });
          }
        }
      });
    });
  }
  /**
   * テンプレート一覧を取得する security modelは要検討。
   * @param templateId AppletテンプレートID
   * @param templateType Appletテンプレートタイプ
   */
  public listTemplates(
    templateId?: Array<string>,
    templateType?: Array<
      "serviceParallel" | "serviceSerial" | "serviceExclusive"
    >
  ): Promise<{ response: http.IncomingMessage; body: InlineResponse2001 }> {
    const localVarPath = this.basePath + "/templates";
    let localVarQueryParameters: any = {};
    let localVarHeaderParams: any = (<any>Object).assign(
      {},
      this.defaultHeaders
    );
    let localVarFormParams: any = {};

    if (templateId !== undefined) {
      localVarQueryParameters["templateId"] = ObjectSerializer.serialize(
        templateId,
        "Array<string>"
      );
    }

    if (templateType !== undefined) {
      localVarQueryParameters["templateType"] = ObjectSerializer.serialize(
        templateType,
        "Array<'serviceParallel' | 'serviceSerial' | 'serviceExclusive'>"
      );
    }

    let localVarUseFormData = false;

    let localVarRequestOptions: localVarRequest.Options = {
      method: "GET",
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true
    };

    this.authentications.JWTToken.applyToRequest(localVarRequestOptions);

    this.authentications.default.applyToRequest(localVarRequestOptions);

    if (Object.keys(localVarFormParams).length) {
      if (localVarUseFormData) {
        (<any>localVarRequestOptions).formData = localVarFormParams;
      } else {
        localVarRequestOptions.form = localVarFormParams;
      }
    }
    return new Promise<{
      response: http.IncomingMessage;
      body: InlineResponse2001;
    }>((resolve, reject) => {
      localVarRequest(localVarRequestOptions, (error, response, body) => {
        if (error) {
          reject(error);
        } else {
          body = ObjectSerializer.deserialize(body, "InlineResponse2001");
          if (
            response.statusCode &&
            response.statusCode >= 200 &&
            response.statusCode <= 299
          ) {
            resolve({ response: response, body: body });
          } else {
            reject({ response: response, body: body });
          }
        }
      });
    });
  }
  /**
   * Appletを登録する。User keyで実行可能。 trigger/service/actionの組み合わせについてはサーバサイドでもvalidateする。 （注）アプレットを新規作成する際に、postAppletStoreStatusとpostAppletGoodNumも同時に行う。
   * @param body
   */
  public postApplet(
    body: Body1
  ): Promise<{ response: http.IncomingMessage; body: Applet }> {
    const localVarPath = this.basePath + "/applets";
    let localVarQueryParameters: any = {};
    let localVarHeaderParams: any = (<any>Object).assign(
      {},
      this.defaultHeaders
    );
    let localVarFormParams: any = {};

    // verify required parameter 'body' is not null or undefined
    if (body === null || body === undefined) {
      throw new Error(
        "Required parameter body was null or undefined when calling postApplet."
      );
    }

    let localVarUseFormData = false;

    let localVarRequestOptions: localVarRequest.Options = {
      method: "POST",
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true,
      body: ObjectSerializer.serialize(body, "Body1")
    };

    this.authentications.JWTToken.applyToRequest(localVarRequestOptions);

    this.authentications.default.applyToRequest(localVarRequestOptions);

    if (Object.keys(localVarFormParams).length) {
      if (localVarUseFormData) {
        (<any>localVarRequestOptions).formData = localVarFormParams;
      } else {
        localVarRequestOptions.form = localVarFormParams;
      }
    }
    return new Promise<{ response: http.IncomingMessage; body: Applet }>(
      (resolve, reject) => {
        localVarRequest(localVarRequestOptions, (error, response, body) => {
          if (error) {
            reject(error);
          } else {
            body = ObjectSerializer.deserialize(body, "Applet");
            if (
              response.statusCode &&
              response.statusCode >= 200 &&
              response.statusCode <= 299
            ) {
              resolve({ response: response, body: body });
            } else {
              reject({ response: response, body: body });
            }
          }
        });
      }
    );
  }
  /**
   * ID指定したAppletのAppletGoodNumを作成する。 postAppletで呼ぶ想定なので、numは0で作成する。
   * @param body
   */
  public postAppletGoodNum(
    body: Body3
  ): Promise<{ response: http.IncomingMessage; body: AppletGoodNum }> {
    const localVarPath = this.basePath + "/appletGoodNum";
    let localVarQueryParameters: any = {};
    let localVarHeaderParams: any = (<any>Object).assign(
      {},
      this.defaultHeaders
    );
    let localVarFormParams: any = {};

    // verify required parameter 'body' is not null or undefined
    if (body === null || body === undefined) {
      throw new Error(
        "Required parameter body was null or undefined when calling postAppletGoodNum."
      );
    }

    let localVarUseFormData = false;

    let localVarRequestOptions: localVarRequest.Options = {
      method: "POST",
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true,
      body: ObjectSerializer.serialize(body, "Body3")
    };

    this.authentications.JWTToken.applyToRequest(localVarRequestOptions);

    this.authentications.default.applyToRequest(localVarRequestOptions);

    if (Object.keys(localVarFormParams).length) {
      if (localVarUseFormData) {
        (<any>localVarRequestOptions).formData = localVarFormParams;
      } else {
        localVarRequestOptions.form = localVarFormParams;
      }
    }
    return new Promise<{ response: http.IncomingMessage; body: AppletGoodNum }>(
      (resolve, reject) => {
        localVarRequest(localVarRequestOptions, (error, response, body) => {
          if (error) {
            reject(error);
          } else {
            body = ObjectSerializer.deserialize(body, "AppletGoodNum");
            if (
              response.statusCode &&
              response.statusCode >= 200 &&
              response.statusCode <= 299
            ) {
              resolve({ response: response, body: body });
            } else {
              reject({ response: response, body: body });
            }
          }
        });
      }
    );
  }
  /**
   * アイコンを登録し、URLを取得する。
   * @param appletId
   * @param image アイコン画像（512以上の正方形）
   */
  public postAppletIcon(
    appletId: string,
    image: Buffer,
    filename: string
  ): Promise<{ response: http.IncomingMessage; body: string }> {
    const localVarPath = this.basePath + "/appletIcon";
    let localVarQueryParameters: any = {};
    let localVarHeaderParams: any = (<any>Object).assign(
      {},
      this.defaultHeaders
    );
    let localVarFormParams: any = {};

    // verify required parameter 'appletId' is not null or undefined
    if (appletId === null || appletId === undefined) {
      throw new Error(
        "Required parameter appletId was null or undefined when calling postAppletIcon."
      );
    }

    // verify required parameter 'image' is not null or undefined
    if (image === null || image === undefined) {
      throw new Error(
        "Required parameter image was null or undefined when calling postAppletIcon."
      );
    }

    if (appletId !== undefined) {
      localVarQueryParameters["appletId"] = ObjectSerializer.serialize(
        appletId,
        "string"
      );
    }

    let localVarUseFormData = false;

    if (image !== undefined) {
      localVarFormParams["image"] = {
        value: image,
        options: { filename: filename }
      };
    }
    localVarUseFormData = true;

    let localVarRequestOptions: localVarRequest.Options = {
      method: "POST",
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true
    };

    this.authentications.JWTToken.applyToRequest(localVarRequestOptions);

    this.authentications.default.applyToRequest(localVarRequestOptions);

    if (Object.keys(localVarFormParams).length) {
      if (localVarUseFormData) {
        (<any>localVarRequestOptions).formData = localVarFormParams;
      } else {
        localVarRequestOptions.form = localVarFormParams;
      }
    }
    return new Promise<{ response: http.IncomingMessage; body: string }>(
      (resolve, reject) => {
        localVarRequest(localVarRequestOptions, (error, response, body) => {
          if (error) {
            reject(error);
          } else {
            body = ObjectSerializer.deserialize(body, "string");
            if (
              response.statusCode &&
              response.statusCode >= 200 &&
              response.statusCode <= 299
            ) {
              resolve({ response: response, body: body });
            } else {
              reject({ response: response, body: body });
            }
          }
        });
      }
    );
  }
  public putAppletIcon(
    appletId: string,
    image: Buffer,
    filename: string
  ): Promise<{ response: http.IncomingMessage; body: string }> {
    const localVarPath = this.basePath + "/appletIcon";
    let localVarQueryParameters: any = {};
    let localVarHeaderParams: any = (<any>Object).assign(
      {},
      this.defaultHeaders
    );
    let localVarFormParams: any = {};

    // verify required parameter 'appletId' is not null or undefined
    if (appletId === null || appletId === undefined) {
      throw new Error(
        "Required parameter appletId was null or undefined when calling putAppletIcon."
      );
    }

    // verify required parameter 'image' is not null or undefined
    if (image === null || image === undefined) {
      throw new Error(
        "Required parameter image was null or undefined when calling putAppletIcon."
      );
    }

    if (appletId !== undefined) {
      localVarQueryParameters["appletId"] = ObjectSerializer.serialize(
        appletId,
        "string"
      );
    }

    let localVarUseFormData = false;

    if (image !== undefined) {
      localVarFormParams["image"] = {
        value: image,
        options: { filename: filename }
      };
    }
    localVarUseFormData = true;

    let localVarRequestOptions: localVarRequest.Options = {
      method: "PUT",
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true
    };

    this.authentications.JWTToken.applyToRequest(localVarRequestOptions);

    this.authentications.default.applyToRequest(localVarRequestOptions);

    if (Object.keys(localVarFormParams).length) {
      if (localVarUseFormData) {
        (<any>localVarRequestOptions).formData = localVarFormParams;
      } else {
        localVarRequestOptions.form = localVarFormParams;
      }
    }
    return new Promise<{ response: http.IncomingMessage; body: string }>(
      (resolve, reject) => {
        localVarRequest(localVarRequestOptions, (error, response, body) => {
          if (error) {
            reject(error);
          } else {
            body = ObjectSerializer.deserialize(body, "string");
            if (
              response.statusCode &&
              response.statusCode >= 200 &&
              response.statusCode <= 299
            ) {
              resolve({ response: response, body: body });
            } else {
              reject({ response: response, body: body });
            }
          }
        });
      }
    );
  }

  /**
   * ID指定したAppletのAppletPublicStatusを作成する。 原則、POST /appletの処理内で呼び出すため、意図的に呼び出す必要はない
   * @param body
   */
  public postAppletPublicStatus(
    body: Body5
  ): Promise<{ response: http.IncomingMessage; body: AppletPublicStatus }> {
    const localVarPath = this.basePath + "/appletPublicStatus";
    let localVarQueryParameters: any = {};
    let localVarHeaderParams: any = (<any>Object).assign(
      {},
      this.defaultHeaders
    );
    let localVarFormParams: any = {};

    // verify required parameter 'body' is not null or undefined
    if (body === null || body === undefined) {
      throw new Error(
        "Required parameter body was null or undefined when calling postAppletPublicStatus."
      );
    }

    let localVarUseFormData = false;

    let localVarRequestOptions: localVarRequest.Options = {
      method: "POST",
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true,
      body: ObjectSerializer.serialize(body, "Body4")
    };

    this.authentications.JWTToken.applyToRequest(localVarRequestOptions);

    this.authentications.default.applyToRequest(localVarRequestOptions);

    if (Object.keys(localVarFormParams).length) {
      if (localVarUseFormData) {
        (<any>localVarRequestOptions).formData = localVarFormParams;
      } else {
        localVarRequestOptions.form = localVarFormParams;
      }
    }
    return new Promise<{
      response: http.IncomingMessage;
      body: AppletPublicStatus;
    }>((resolve, reject) => {
      localVarRequest(localVarRequestOptions, (error, response, body) => {
        if (error) {
          reject(error);
        } else {
          body = ObjectSerializer.deserialize(body, "AppletPublicStatus");
          if (
            response.statusCode &&
            response.statusCode >= 200 &&
            response.statusCode <= 299
          ) {
            resolve({ response: response, body: body });
          } else {
            reject({ response: response, body: body });
          }
        }
      });
    });
  }
  /**
   * ID指定したAppletの審査ステータスを作成する。 postAppletで呼ぶ想定。
   * @param body
   */
  public postAppletStoreStatus(
    body: Body7
  ): Promise<{ response: http.IncomingMessage; body: AppletStoreStatus }> {
    const localVarPath = this.basePath + "/appletStoreStatus";
    let localVarQueryParameters: any = {};
    let localVarHeaderParams: any = (<any>Object).assign(
      {},
      this.defaultHeaders
    );
    let localVarFormParams: any = {};

    // verify required parameter 'body' is not null or undefined
    if (body === null || body === undefined) {
      throw new Error(
        "Required parameter body was null or undefined when calling postAppletStoreStatus."
      );
    }

    let localVarUseFormData = false;

    let localVarRequestOptions: localVarRequest.Options = {
      method: "POST",
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true,
      body: ObjectSerializer.serialize(body, "Body7")
    };

    this.authentications.JWTToken.applyToRequest(localVarRequestOptions);

    this.authentications.default.applyToRequest(localVarRequestOptions);

    if (Object.keys(localVarFormParams).length) {
      if (localVarUseFormData) {
        (<any>localVarRequestOptions).formData = localVarFormParams;
      } else {
        localVarRequestOptions.form = localVarFormParams;
      }
    }
    return new Promise<{
      response: http.IncomingMessage;
      body: AppletStoreStatus;
    }>((resolve, reject) => {
      localVarRequest(localVarRequestOptions, (error, response, body) => {
        if (error) {
          reject(error);
        } else {
          body = ObjectSerializer.deserialize(body, "AppletStoreStatus");
          if (
            response.statusCode &&
            response.statusCode >= 200 &&
            response.statusCode <= 299
          ) {
            resolve({ response: response, body: body });
          } else {
            reject({ response: response, body: body });
          }
        }
      });
    });
  }
  /**
   * APNs用の証明書を登録・更新する. Dodaiルートキーを使う.
   * @param vendorId 証明書に対応するvendorID
   * @param cert APNs用のp12証明書
   * @param pass p12証明書のパスワード
   * @param production 証明書がproduction / sandbox用かを表すフラグ
   * @param {*} [options] Override http request options.
   */
  public postCert(
    vendorId: string,
    cert: Buffer,
    pass: string,
    production: boolean,
    options: any = {}
  ): Promise<{ response: http.IncomingMessage; body: string }> {
    const localVarPath = this.basePath + "/push/cert";
    let localVarQueryParameters: any = {};
    let localVarHeaderParams: any = (<any>Object).assign(
      {},
      this.defaultHeaders
    );
    let localVarFormParams: any = {};

    // verify required parameter 'vendorId' is not null or undefined
    if (vendorId === null || vendorId === undefined) {
      throw new Error(
        "Required parameter vendorId was null or undefined when calling postCert."
      );
    }

    // verify required parameter 'cert' is not null or undefined
    if (cert === null || cert === undefined) {
      throw new Error(
        "Required parameter cert was null or undefined when calling postCert."
      );
    }

    // verify required parameter 'pass' is not null or undefined
    if (pass === null || pass === undefined) {
      throw new Error(
        "Required parameter pass was null or undefined when calling postCert."
      );
    }

    // verify required parameter 'production' is not null or undefined
    if (production === null || production === undefined) {
      throw new Error(
        "Required parameter production was null or undefined when calling postCert."
      );
    }

    (<any>Object).assign(localVarHeaderParams, options.headers);

    let localVarUseFormData = false;

    if (vendorId !== undefined) {
      localVarFormParams["vendorId"] = ObjectSerializer.serialize(
        vendorId,
        "string"
      );
    }

    if (cert !== undefined) {
      //localVarFormParams["cert"] = cert;
      localVarFormParams["cert"] = {
        value: cert,
        options: { filename: "test.cert" }
      };
    }
    localVarUseFormData = true;

    if (pass !== undefined) {
      localVarFormParams["pass"] = ObjectSerializer.serialize(pass, "string");
    }

    if (production !== undefined) {
      localVarFormParams["production"] = new Boolean(production).toString();
    }

    let localVarRequestOptions: localVarRequest.Options = {
      method: "POST",
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true
    };

    this.authentications.default.applyToRequest(localVarRequestOptions);

    this.authentications.JWTToken.applyToRequest(localVarRequestOptions);

    if (Object.keys(localVarFormParams).length) {
      if (localVarUseFormData) {
        (<any>localVarRequestOptions).formData = localVarFormParams;
      } else {
        localVarRequestOptions.form = localVarFormParams;
      }
    }
    return new Promise<{ response: http.IncomingMessage; body: string }>(
      (resolve, reject) => {
        localVarRequest(localVarRequestOptions, (error, response, body) => {
          if (error) {
            reject(error);
          } else {
            body = ObjectSerializer.deserialize(body, "string");
            if (
              response.statusCode &&
              response.statusCode >= 200 &&
              response.statusCode <= 299
            ) {
              resolve({ response: response, body: body });
            } else {
              reject({ response: response, body: body });
            }
          }
        });
      }
    );
  }
  /**
   * Appletを変更する。User keyで実行可能。 trigger/service/actionの組み合わせについてはサーバサイドでもvalidateする。
   * @param body
   */
  public putApplet(
    body: Body
  ): Promise<{ response: http.IncomingMessage; body: Applet }> {
    const localVarPath = this.basePath + "/applets";
    let localVarQueryParameters: any = {};
    let localVarHeaderParams: any = (<any>Object).assign(
      {},
      this.defaultHeaders
    );
    let localVarFormParams: any = {};

    // verify required parameter 'body' is not null or undefined
    if (body === null || body === undefined) {
      throw new Error(
        "Required parameter body was null or undefined when calling putApplet."
      );
    }

    let localVarUseFormData = false;

    let localVarRequestOptions: localVarRequest.Options = {
      method: "PUT",
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true,
      body: ObjectSerializer.serialize(body, "Body")
    };

    this.authentications.JWTToken.applyToRequest(localVarRequestOptions);

    this.authentications.default.applyToRequest(localVarRequestOptions);

    if (Object.keys(localVarFormParams).length) {
      if (localVarUseFormData) {
        (<any>localVarRequestOptions).formData = localVarFormParams;
      } else {
        localVarRequestOptions.form = localVarFormParams;
      }
    }
    return new Promise<{ response: http.IncomingMessage; body: Applet }>(
      (resolve, reject) => {
        localVarRequest(localVarRequestOptions, (error, response, body) => {
          if (error) {
            reject(error);
          } else {
            body = ObjectSerializer.deserialize(body, "Applet");
            if (
              response.statusCode &&
              response.statusCode >= 200 &&
              response.statusCode <= 299
            ) {
              resolve({ response: response, body: body });
            } else {
              reject({ response: response, body: body });
            }
          }
        });
      }
    );
  }
  /**
   * ID指定したAppletのイイネ！の数を変更する。
   * @param body
   */
  public putAppletGoodNum(
    body: Body2
  ): Promise<{ response: http.IncomingMessage; body: AppletGoodNum }> {
    const localVarPath = this.basePath + "/appletGoodNum";
    let localVarQueryParameters: any = {};
    let localVarHeaderParams: any = (<any>Object).assign(
      {},
      this.defaultHeaders
    );
    let localVarFormParams: any = {};

    // verify required parameter 'body' is not null or undefined
    if (body === null || body === undefined) {
      throw new Error(
        "Required parameter body was null or undefined when calling putAppletGoodNum."
      );
    }

    let localVarUseFormData = false;

    let localVarRequestOptions: localVarRequest.Options = {
      method: "PUT",
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true,
      body: ObjectSerializer.serialize(body, "Body2")
    };

    this.authentications.JWTToken.applyToRequest(localVarRequestOptions);

    this.authentications.default.applyToRequest(localVarRequestOptions);

    if (Object.keys(localVarFormParams).length) {
      if (localVarUseFormData) {
        (<any>localVarRequestOptions).formData = localVarFormParams;
      } else {
        localVarRequestOptions.form = localVarFormParams;
      }
    }
    return new Promise<{ response: http.IncomingMessage; body: AppletGoodNum }>(
      (resolve, reject) => {
        localVarRequest(localVarRequestOptions, (error, response, body) => {
          if (error) {
            reject(error);
          } else {
            body = ObjectSerializer.deserialize(body, "AppletGoodNum");
            if (
              response.statusCode &&
              response.statusCode >= 200 &&
              response.statusCode <= 299
            ) {
              resolve({ response: response, body: body });
            } else {
              reject({ response: response, body: body });
            }
          }
        });
      }
    );
  }
  /**
   * ID指定したAppletのAppletPublicStatusを変更する。 原則、PUT /appletの処理内で呼び出すため、意図的に呼び出す必要はない
   * @param body
   */
  public putAppletPublicStatus(
    body: Body4
  ): Promise<{ response: http.IncomingMessage; body: AppletPublicStatus }> {
    const localVarPath = this.basePath + "/appletPublicStatus";
    let localVarQueryParameters: any = {};
    let localVarHeaderParams: any = (<any>Object).assign(
      {},
      this.defaultHeaders
    );
    let localVarFormParams: any = {};

    // verify required parameter 'body' is not null or undefined
    if (body === null || body === undefined) {
      throw new Error(
        "Required parameter body was null or undefined when calling putAppletPublicStatus."
      );
    }

    let localVarUseFormData = false;

    let localVarRequestOptions: localVarRequest.Options = {
      method: "PUT",
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true,
      body: ObjectSerializer.serialize(body, "Body5")
    };

    this.authentications.JWTToken.applyToRequest(localVarRequestOptions);

    this.authentications.default.applyToRequest(localVarRequestOptions);

    if (Object.keys(localVarFormParams).length) {
      if (localVarUseFormData) {
        (<any>localVarRequestOptions).formData = localVarFormParams;
      } else {
        localVarRequestOptions.form = localVarFormParams;
      }
    }
    return new Promise<{
      response: http.IncomingMessage;
      body: AppletPublicStatus;
    }>((resolve, reject) => {
      localVarRequest(localVarRequestOptions, (error, response, body) => {
        if (error) {
          reject(error);
        } else {
          body = ObjectSerializer.deserialize(body, "AppletPublicStatus");
          if (
            response.statusCode &&
            response.statusCode >= 200 &&
            response.statusCode <= 299
          ) {
            resolve({ response: response, body: body });
          } else {
            reject({ response: response, body: body });
          }
        }
      });
    });
  }
  /**
   * ID指定したAppletの審査ステータスを変更する。
   * @param body
   */
  public putAppletStoreStatus(
    body: Body7
  ): Promise<{ response: http.IncomingMessage; body: AppletStoreStatus }> {
    const localVarPath = this.basePath + "/appletStoreStatus";
    let localVarQueryParameters: any = {};
    let localVarHeaderParams: any = (<any>Object).assign(
      {},
      this.defaultHeaders
    );
    let localVarFormParams: any = {};

    // verify required parameter 'body' is not null or undefined
    if (body === null || body === undefined) {
      throw new Error(
        "Required parameter body was null or undefined when calling putAppletStoreStatus."
      );
    }

    let localVarUseFormData = false;

    let localVarRequestOptions: localVarRequest.Options = {
      method: "PUT",
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true,
      body: ObjectSerializer.serialize(body, "Body7")
    };

    this.authentications.JWTToken.applyToRequest(localVarRequestOptions);

    this.authentications.default.applyToRequest(localVarRequestOptions);

    if (Object.keys(localVarFormParams).length) {
      if (localVarUseFormData) {
        (<any>localVarRequestOptions).formData = localVarFormParams;
      } else {
        localVarRequestOptions.form = localVarFormParams;
      }
    }
    return new Promise<{
      response: http.IncomingMessage;
      body: AppletStoreStatus;
    }>((resolve, reject) => {
      localVarRequest(localVarRequestOptions, (error, response, body) => {
        if (error) {
          reject(error);
        } else {
          body = ObjectSerializer.deserialize(body, "AppletStoreStatus");
          if (
            response.statusCode &&
            response.statusCode >= 200 &&
            response.statusCode <= 299
          ) {
            resolve({ response: response, body: body });
          } else {
            reject({ response: response, body: body });
          }
        }
      });
    });
  }
  /**
   * Appletテンプレートを更新する。 security modelは要検討。
   * @param template
   */
  public putTemplate(
    template: Template
  ): Promise<{ response: http.IncomingMessage; body: AppletTemplate }> {
    const localVarPath = this.basePath + "/templates";
    let localVarQueryParameters: any = {};
    let localVarHeaderParams: any = (<any>Object).assign(
      {},
      this.defaultHeaders
    );
    let localVarFormParams: any = {};

    // verify required parameter 'template' is not null or undefined
    if (template === null || template === undefined) {
      throw new Error(
        "Required parameter template was null or undefined when calling putTemplate."
      );
    }

    let localVarUseFormData = false;

    let localVarRequestOptions: localVarRequest.Options = {
      method: "PUT",
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true,
      body: ObjectSerializer.serialize(template, "Template")
    };

    this.authentications.JWTToken.applyToRequest(localVarRequestOptions);

    this.authentications.default.applyToRequest(localVarRequestOptions);

    if (Object.keys(localVarFormParams).length) {
      if (localVarUseFormData) {
        (<any>localVarRequestOptions).formData = localVarFormParams;
      } else {
        localVarRequestOptions.form = localVarFormParams;
      }
    }
    return new Promise<{
      response: http.IncomingMessage;
      body: AppletTemplate;
    }>((resolve, reject) => {
      localVarRequest(localVarRequestOptions, (error, response, body) => {
        if (error) {
          reject(error);
        } else {
          body = ObjectSerializer.deserialize(body, "AppletTemplate");
          if (
            response.statusCode &&
            response.statusCode >= 200 &&
            response.statusCode <= 299
          ) {
            resolve({ response: response, body: body });
          } else {
            reject({ response: response, body: body });
          }
        }
      });
    });
  }
  /**
   * テンプレートを登録する security modelは要検討。
   * @param body
   */
  public registTemplate(
    body: Body8
  ): Promise<{ response: http.IncomingMessage; body: AppletTemplate }> {
    const localVarPath = this.basePath + "/templates";
    let localVarQueryParameters: any = {};
    let localVarHeaderParams: any = (<any>Object).assign(
      {},
      this.defaultHeaders
    );
    let localVarFormParams: any = {};

    // verify required parameter 'body' is not null or undefined
    if (body === null || body === undefined) {
      throw new Error(
        "Required parameter body was null or undefined when calling registTemplate."
      );
    }

    let localVarUseFormData = false;

    let localVarRequestOptions: localVarRequest.Options = {
      method: "POST",
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true,
      body: ObjectSerializer.serialize(body, "Body8")
    };

    this.authentications.JWTToken.applyToRequest(localVarRequestOptions);

    this.authentications.default.applyToRequest(localVarRequestOptions);

    if (Object.keys(localVarFormParams).length) {
      if (localVarUseFormData) {
        (<any>localVarRequestOptions).formData = localVarFormParams;
      } else {
        localVarRequestOptions.form = localVarFormParams;
      }
    }
    return new Promise<{
      response: http.IncomingMessage;
      body: AppletTemplate;
    }>((resolve, reject) => {
      localVarRequest(localVarRequestOptions, (error, response, body) => {
        if (error) {
          reject(error);
        } else {
          body = ObjectSerializer.deserialize(body, "AppletTemplate");
          if (
            response.statusCode &&
            response.statusCode >= 200 &&
            response.statusCode <= 299
          ) {
            resolve({ response: response, body: body });
          } else {
            reject({ response: response, body: body });
          }
        }
      });
    });
  }
  /**
   * ユーザに紐づくデバイスにpush通知を送る 複数デバイスが登録されている場合は全デバイスに送る
   * @param body
   * @param {*} [options] Override http request options.
   */
  public sendPush(
    body: Body10,
    options: any = {}
  ): Promise<{ response: http.IncomingMessage; body?: any }> {
    const localVarPath = this.basePath + "/push/send";
    let localVarQueryParameters: any = {};
    let localVarHeaderParams: any = (<any>Object).assign(
      {},
      this.defaultHeaders
    );
    let localVarFormParams: any = {};

    // verify required parameter 'body' is not null or undefined
    if (body === null || body === undefined) {
      throw new Error(
        "Required parameter body was null or undefined when calling sendPush."
      );
    }

    (<any>Object).assign(localVarHeaderParams, options.headers);

    let localVarUseFormData = false;

    let localVarRequestOptions: localVarRequest.Options = {
      method: "POST",
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true,
      body: ObjectSerializer.serialize(body, "Body10")
    };

    this.authentications.JWTToken.applyToRequest(localVarRequestOptions);

    this.authentications.default.applyToRequest(localVarRequestOptions);

    if (Object.keys(localVarFormParams).length) {
      if (localVarUseFormData) {
        (<any>localVarRequestOptions).formData = localVarFormParams;
      } else {
        localVarRequestOptions.form = localVarFormParams;
      }
    }
    return new Promise<{ response: http.IncomingMessage; body?: any }>(
      (resolve, reject) => {
        localVarRequest(localVarRequestOptions, (error, response, body) => {
          if (error) {
            reject(error);
          } else {
            if (
              response.statusCode &&
              response.statusCode >= 200 &&
              response.statusCode <= 299
            ) {
              resolve({ response: response, body: body });
            } else {
              reject({ response: response, body: body });
            }
          }
        });
      }
    );
  }
}

const wrap = async (proc: () => Promise<DodaiResponseType>) => {
  try {
return await proc()
  } catch( e ) {
let code = 400;
if ('result' in e) {
    let result = e.result()
    if (result.errcode == 1002) {
  let m = result.body.code.match('([0-9]*)-([0-9]*)')
  if (m) {
      code = parseInt(m[1])
  }
    }
} else if ('code' in e) {
    let m = e.code.match('([0-9]*)-([0-9]*)')
    if (m) {
  code = parseInt(m[1])
    }
}
return { status: code, body: e } as DodaiResponseType
  }
}

const get = (ds: riiiverdb.DatastoreForRead, collection: string, id: any, key: string, opts?: any) : Promise<DodaiResponseType> => {
  return wrap( async () => {
let result = await ds.get(
    collection,
    id,
    Object.assign({}, opts||{}, {credential:key}));
return { status: 200, body: result } as DodaiResponseType;
  });
};

export function getAppletIcon (ds: riiiverdb.DatastoreForRead, applet_id: string, key: string)  {
  return get(ds, riiiverdb.APPLET_ICON, applet_id, key);
}

export function getApplet (ds: riiiverdb.DatastoreForRead, applet_id: string, key: string)  {
  return get(ds, riiiverdb.APPLET, applet_id, key);
}
